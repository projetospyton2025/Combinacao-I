ESTA TUDO FUNCIONAL  N√ÉO ALTERE NADA - N√ÉO MEXA NA L√ìGICA FOQUE APENAS NO VOU FALAR


# Limitar o n√∫mero m√°ximo de palpites para evitar timeout
max_palpites = 10000  # Ajuste conforme necess√°rio
if total_palpites > max_palpites:
app.logger.warning(f'Solicita√ß√£o de {total_palpites} palpites excede o limite de {max_palpites}')
total_palpites = max_palpites


Se voc√™ quer remover o limite de palpites e permitir que o sistema gere at√© o limite te√≥rico calculado, 
voc√™ pode simplesmente remover essa verifica√ß√£o no c√≥digo. 
Aqui est√° como voc√™ deve modificar essa parte do c√≥digo no arquivo app.py:


@app.route("/gerar_palpites", methods=["POST"])
def gerar_palpites():
    try:
        dados = request.get_json()
        if not dados:
            app.logger.error('Dados JSON n√£o recebidos ou inv√°lidos')
            return jsonify({"erro": "Dados JSON inv√°lidos ou n√£o fornecidos"}), 400
            
        combinacoes_formatadas = dados.get("combinacoes", [])
        total_palpites = int(dados.get("quantidade", 10))
        
        app.logger.info(f'Gerando {total_palpites} palpites para a Mega Sena.')
        
        # Valida√ß√£o
        if not combinacoes_formatadas or total_palpites <= 0:
            app.logger.warning('Dados de entrada para gera√ß√£o de palpites inv√°lidos')
            return jsonify({"erro": "Dados inv√°lidos"}), 400
        
        # Remova o c√≥digo de limita√ß√£o aqui - vamos deixar gerar qualquer quantidade solicitada
        # Apenas registrar no log para fins de monitoramento
        if total_palpites > 10000:
            app.logger.info(f'Gerando uma quantidade grande de palpites: {total_palpites}')
            
        # Definir timeout para evitar que o servidor fique bloqueado
        start_time = time.time()
        palpites = gerar_palpites_mega_sena(combinacoes_formatadas, total_palpites)
        execution_time = time.time() - start_time
        
        app.logger.info(f'Gerados {len(palpites)} palpites em {execution_time:.2f} segundos')
        
        return jsonify({"total": len(palpites), "palpites": palpites})
    
    except Exception as e:
        app.logger.error(f'Erro inesperado ao gerar palpites: {str(e)}')
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({"erro": f"Erro inesperado: {str(e)}"}), 500


Tamb√©m √© importante ajustar a configura√ß√£o do servidor Flask para aumentar o timeout e permitir processar 
requisi√ß√µes por mais tempo. No seu arquivo app.py, voc√™ pode adicionar estas linhas antes de iniciar o servidor:


if __name__ == '__main__':
    # Aumentar o timeout de resposta do servidor
    port = int(os.environ.get("PORT", 10000))
    from werkzeug.serving import run_simple
    run_simple('0.0.0.0', port, app, threaded=True, use_reloader=True)
	
	
	
	
	No entanto, esteja ciente de que remover esse limite pode ter consequ√™ncias:

O servidor pode ficar sobrecarregado processando requisi√ß√µes grandes
Os usu√°rios podem enfrentar timeouts no navegador se a gera√ß√£o demorar muito
A mem√≥ria do servidor pode esgotar com conjuntos de dados muito grandes

Uma abordagem mais segura seria implementar um sistema onde grandes quantidades de palpites s√£o geradas em segundo plano e os resultados s√£o armazenados para o usu√°rio baixar posteriormente, em vez de tentar entregar tudo em uma √∫nica resposta HTTP.
Se voc√™ realmente precisar entregar grandes quantidades em uma s√≥ requisi√ß√£o, considere aumentar os tempos de timeout tanto no servidor quanto no cliente:
	
	
	// No c√≥digo do cliente, aumente o timeout para 5 minutos (300000 ms)
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 300000);
	



Diret√≥rio: J:\Meu Drive\ProjetosPython\Loterias\Combinacoes\Combinacao-I


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        23/02/2025     05:58                Requisitos
d-----        01/03/2025     06:16                templates
d-----        23/02/2025     05:58                static
d-----        01/03/2025     06:21                logs
d-----        23/02/2025     05:58                venv
d-----        28/02/2025     15:23                __pycache__
------        23/02/2025     05:15           1096 LICENSE
------        23/02/2025     06:52              0 README.md
------        23/02/2025     06:41          10138 combinacaoI.ps1
------        28/02/2025     15:36          13718 app.py
------        28/02/2025     16:16           1381 requirements.txt
------        28/02/2025     11:57            559 .env
------        27/02/2025     05:43            221 .gitignore
------        28/02/2025     12:15           6048 paralelizacao.py
------        28/02/2025     12:15           3776 gospers_hack.py
------        28/02/2025     15:18           1110 celery_config.py
------        28/02/2025     14:23           7180 celery_tasks.py
------        01/03/2025     06:07           3868 socketio_server.py
------        28/02/2025     14:30           1248 supervisord.conf
------        01/03/2025     06:04            500 redis_config.py
------        01/03/2025     06:17            862 start_servers.bat


[17756] 01 Mar 06:24:02.562 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
[17756] 01 Mar 06:24:02.562 # Redis version=5.0.14.1, bits=64, commit=ec77f72d, modified=0, pid=17756, just started
[17756] 01 Mar 06:24:02.562 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server.exe /path/to/redis.conf
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 5.0.14.1 (ec77f72d/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 17756
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

[17756] 01 Mar 06:24:02.569 # Server initialized
[17756] 01 Mar 06:24:02.569 * Ready to accept connections



Server initialized for eventlet.
2025-03-01 06:24:19,030 - engineio.server - INFO - Server initialized for eventlet.
2025-03-01 06:24:19,034 - __main__ - INFO - Iniciando servidor Socket.IO na porta 10001
2025-03-01 06:24:19,034 - werkzeug - INFO -  * Restarting with stat
2025-03-01 06:24:19,075 - __main__ - INFO - Iniciando thread de escuta do Redis
Server initialized for eventlet.
2025-03-01 06:24:25,865 - engineio.server - INFO - Server initialized for eventlet.
2025-03-01 06:24:25,868 - __main__ - INFO - Iniciando servidor Socket.IO na porta 10001
2025-03-01 06:24:25,868 - werkzeug - WARNING -  * Debugger is active!
2025-03-01 06:24:25,878 - werkzeug - INFO -  * Debugger PIN: 126-240-498
2025-03-01 06:24:25,945 - __main__ - INFO - Iniciando thread de escuta do Redis
(5180) wsgi starting up on http://0.0.0.0:10001



 -------------- celery@DESKTOP-S47OMAV v5.4.0 (opalescent)
--- ***** -----
-- ******* ---- Windows-10-10.0.19045-SP0 2025-03-01 06:24:14
- *** --- * ---
- ** ---------- [config]
- ** ---------- .> app:         combinacoes:0x28973d361b0
- ** ---------- .> transport:   redis://default:**@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833//
- ** ---------- .> results:     redis://default:**@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833/
- *** --- * --- .> concurrency: 4 (solo)
-- ******* ---- .> task events: OFF (enable -E to monitor tasks in this worker)
--- ***** -----
 -------------- [queues]
                .> celery           exchange=celery(direct) key=celery


[tasks]
  . celery_tasks.gerar_palpites_tarefa

[2025-03-01 06:24:14,352: WARNING/MainProcess] J:\Meu Drive\ProjetosPython\Loterias\Combinacoes\Combinacao-I\venv\Lib\site-packages\celery\worker\consumer\consumer.py:508: CPendingDeprecationWarning: The broker_connection_retry configuration setting will no longer determine
whether broker connection retries are made during startup in Celery 6.0 and above.
If you wish to retain the existing behavior for retrying connections on startup,
you should set broker_connection_retry_on_startup to True.
  warnings.warn(

[2025-03-01 06:24:14,455: INFO/MainProcess] Connected to redis://default:**@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833//
[2025-03-01 06:24:14,456: WARNING/MainProcess] J:\Meu Drive\ProjetosPython\Loterias\Combinacoes\Combinacao-I\venv\Lib\site-packages\celery\worker\consumer\consumer.py:508: CPendingDeprecationWarning: The broker_connection_retry configuration setting will no longer determine
whether broker connection retries are made during startup in Celery 6.0 and above.
If you wish to retain the existing behavior for retrying connections on startup,
you should set broker_connection_retry_on_startup to True.
  warnings.warn(

[2025-03-01 06:24:14,499: INFO/MainProcess] mingle: searching for neighbors
[2025-03-01 06:24:15,724: INFO/MainProcess] mingle: all alone
[2025-03-01 06:24:15,954: INFO/MainProcess] celery@DESKTOP-S47OMAV ready.


‚úÖ Arquivo .env encontrado: J:\Meu Drive\ProjetosPython\Loterias\Combinacoes\Combinacao-I\.env
üîç REDIS_URL: redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833
‚úÖ Conex√£o com o Redis estabelecida com sucesso!
[2025-03-01 06:24:20,711] INFO in app: Iniciando aplica√ß√£o de combina√ß√µes
 * Serving Flask app 'app' (lazy loading)
 * Environment: development
 * Debug mode: on
 * Restarting with stat
‚úÖ Arquivo .env encontrado: J:\Meu Drive\ProjetosPython\Loterias\Combinacoes\Combinacao-I\.env
üîç REDIS_URL: redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833
‚úÖ Conex√£o com o Redis estabelecida com sucesso!
[2025-03-01 06:24:24,316] INFO in app: Iniciando aplica√ß√£o de combina√ß√µes
 * Debugger is active!
 * Debugger PIN: 350-416-125
 * Running on all addresses.
   WARNING: This is a development server. Do not use it in a production deployment.
 * Running on http://10.0.0.127:10000/ (Press CTRL+C to quit)
 
 
 
 
from flask import Flask, render_template, request, jsonify, url_for
from dotenv import load_dotenv, find_dotenv
import itertools
from typing import List, Set
import logging
from logging.handlers import RotatingFileHandler
import os
import random
import redis
import time  # Para o caso de uso de sleep no c√≥digo


# Tenta encontrar e carregar o arquivo .env
dotenv_path = find_dotenv()
if not dotenv_path:
    print("‚ùå ERRO: Arquivo .env n√£o encontrado!")
else:
    print(f"‚úÖ Arquivo .env encontrado: {dotenv_path}")
    load_dotenv(dotenv_path)

# Pegando a URL do Redis
REDIS_URL = os.getenv("REDIS_URL")

print(f"üîç REDIS_URL: {REDIS_URL}")  # Deve exibir a URL do Redis, n√£o None!

if not REDIS_URL:
    print("‚ùå ERRO: REDIS_URL n√£o foi carregada! Verifique o .env ou defina manualmente.")
    exit(1)  # Encerra o programa se a vari√°vel n√£o foi carregada corretamente

try:
    # Criando a conex√£o com o Redis
    redis_client = redis.Redis.from_url(REDIS_URL, decode_responses=True)
    
    # Testando a conex√£o
    redis_client.ping()
    print("‚úÖ Conex√£o com o Redis estabelecida com sucesso!")

except Exception as e:
    print(f"‚ùå Erro ao conectar ao Redis: {type(e).__name__} - {e}")








app = Flask(__name__)

# Configura√ß√£o de logs
if not os.path.exists('logs'):
    os.mkdir('logs')
file_handler = RotatingFileHandler('logs/combinacoes.log', maxBytes=10240, backupCount=10)
file_handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
))
file_handler.setLevel(logging.INFO)
app.logger.addHandler(file_handler)
app.logger.setLevel(logging.INFO)
app.logger.info('Iniciando aplica√ß√£o de combina√ß√µes')

def gerar_combinacoes(numeros: List[int], tamanho: int) -> Set[tuple]:
    """
    Gera combina√ß√µes normais e adiciona combina√ß√µes g√™meas.
    """
    # Gerar combina√ß√µes normais usando permuta√ß√µes dos n√∫meros originais
    combinacoes = set(itertools.permutations(numeros, tamanho))
    
    # Adicionar combina√ß√µes g√™meas (onde os dois d√≠gitos s√£o iguais)
    for num in numeros:
        if 1 <= num <= 9:
            gemeo = (num, num)  # Por exemplo, (1,1) para formar "11"
            combinacoes.add(gemeo)
    
    return combinacoes

def formatar_numero(combinacao: tuple) -> str:
    """Formata uma combina√ß√£o como uma string de d√≠gitos concatenados."""
    return "".join(map(str, combinacao))

@app.route("/")
def index():
    socketio_url = f"http://{request.host.split(':')[0]}:10001"
    return render_template("index.html", socketio_url=socketio_url)


@app.route("/calcular", methods=["POST"])
def calcular():
    try:
        dados = request.get_json()
        numeros_str = dados.get("numeros", "")
        tamanho = int(dados.get("tamanho", 0))
        
        app.logger.info(f'Calculando combina√ß√µes para n√∫meros: {numeros_str}, tamanho: {tamanho}')
        
        # Valida√ß√£o dos dados
        if not numeros_str or tamanho < 1:
            app.logger.warning('Dados inv√°lidos recebidos')
            return jsonify({"erro": "Dados inv√°lidos"}), 400
        
        # Validar d√≠gitos √∫nicos
        valido, msg_erro = validar_digitos_unicos(numeros_str)
        if not valido:
            app.logger.warning(f'Valida√ß√£o de d√≠gitos falhou: {msg_erro}')
            return jsonify({"erro": msg_erro}), 400
        
        # Processamento dos n√∫meros - agora garantimos que s√£o d√≠gitos √∫nicos
        numeros = [int(n.strip()) for n in numeros_str.split(",") if n.strip()]
        
        # C√°lculo das combina√ß√µes
        combinacoes = gerar_combinacoes(numeros, tamanho)
        combinacoes_formatadas = [formatar_numero(c) for c in combinacoes]
        
        # Filtrar combina√ß√µes que resultam em n√∫meros maiores que 60 (limite da Mega Sena)
        combinacoes_filtradas = []
        for comb in combinacoes_formatadas:
            try:
                num = int(comb)
                if 1 <= num <= 60:  # Intervalo v√°lido para Mega Sena
                    combinacoes_filtradas.append(comb)
            except ValueError:
                pass  # Ignorar valores que n√£o podem ser convertidos para int
                
        # Ordenar numericamente
        combinacoes_filtradas.sort(key=lambda x: int(x))
        
        # Registrar quantas combina√ß√µes foram filtradas
        total_combinacoes = len(combinacoes_formatadas)
        total_filtradas = len(combinacoes_filtradas)
        app.logger.info(f'Geradas {total_combinacoes} combina√ß√µes, {total_filtradas} ap√≥s filtrar n√∫meros > 60')
        
        return jsonify({
            "total": total_filtradas,
            "combinacoes": combinacoes_filtradas,
            "formatado_para_excel": True
        })
        
    except ValueError as e:
        app.logger.error(f'Erro nos dados de entrada: {str(e)}')
        return jsonify({"erro": f"Erro nos dados de entrada: {str(e)}"}), 400
    except Exception as e:
        app.logger.error(f'Erro inesperado: {str(e)}')
        return jsonify({"erro": f"Erro inesperado: {str(e)}"}), 500




# Fun√ß√£o otimizada de gerar palpites para a Mega Sena
def gerar_palpites_mega_sena(combinacoes_formatadas, total_palpites=10):
    """
    Gera palpites para a Mega Sena a partir das combina√ß√µes de dois d√≠gitos.
    Cada palpite cont√©m 6 n√∫meros √∫nicos entre 1 e 60.
    
    Args:
        combinacoes_formatadas: Lista de combina√ß√µes de dois d√≠gitos j√° formatadas
        total_palpites: N√∫mero de palpites a serem gerados
        
    Returns:
        Uma lista de palpites, onde cada palpite √© uma lista de 6 n√∫meros √∫nicos
    """
    numeros_unicos = set()
    
    # Extrair n√∫meros das combina√ß√µes de dois d√≠gitos
    for combinacao in combinacoes_formatadas:
        i = 0
        while i < len(combinacao):
            # Tentar extrair um n√∫mero de 2 d√≠gitos
            if i + 1 < len(combinacao):
                try:
                    num_str = combinacao[i:i+2]
                    numero = int(num_str)
                    if 1 <= numero <= 60:  # Garantir que est√° no intervalo da Mega Sena
                        numeros_unicos.add(numero)
                except ValueError:
                    pass
            i += 2  # Avan√ßar para o pr√≥ximo par de d√≠gitos
    
    # Converter o conjunto para lista para facilitar a manipula√ß√£o
    numeros_disponiveis = list(numeros_unicos)
    
    # Se n√£o houver n√∫meros suficientes, complementar com n√∫meros aleat√≥rios
    if len(numeros_disponiveis) < 6:
        numeros_faltantes = set(range(1, 61)) - set(numeros_disponiveis)
        numeros_complementares = random.sample(list(numeros_faltantes), 6 - len(numeros_disponiveis))
        numeros_disponiveis.extend(numeros_complementares)
    
    # Garantir que temos pelo menos 6 n√∫meros
    if len(numeros_disponiveis) < 6:
        raise ValueError("N√£o foi poss√≠vel extrair n√∫meros suficientes das combina√ß√µes")
    
    # Para gera√ß√£o de grandes quantidades, usamos uma abordagem mais eficiente
    if total_palpites > 100:
        return gerar_palpites_grande_quantidade(numeros_disponiveis, total_palpites)
    
    # Para quantidades menores, usamos a abordagem normal
    palpites = []
    tentativas_maximas = total_palpites * 3  # Tentativas extras caso gere duplicatas
    tentativas = 0
    
    while len(palpites) < total_palpites and tentativas < tentativas_maximas:
        tentativas += 1
        
        # Se tivermos muitos n√∫meros dispon√≠veis, podemos gerar mais varia√ß√µes
        if len(numeros_disponiveis) > 15:
            # Escolher 6 n√∫meros aleat√≥rios do conjunto dispon√≠vel
            palpite = sorted(random.sample(numeros_disponiveis, 6))
        else:
            # Para conjuntos menores, podemos precisar de uma abordagem mais criativa
            # Garantir que pelo menos 3 n√∫meros sejam dos dispon√≠veis
            n_fixos = min(3, len(numeros_disponiveis))
            numeros_fixos = random.sample(numeros_disponiveis, n_fixos)
            
            # Complementar com n√∫meros aleat√≥rios entre 1-60 que n√£o estejam nos fixos
            numeros_adicionais = []
            while len(numeros_fixos) + len(numeros_adicionais) < 6:
                novo_num = random.randint(1, 60)
                if novo_num not in numeros_fixos and novo_num not in numeros_adicionais:
                    numeros_adicionais.append(novo_num)
            
            # Juntar e ordenar
            palpite = sorted(numeros_fixos + numeros_adicionais)
        
        # Verificar se esse palpite j√° existe
        palpite_str = ",".join(map(str, palpite))
        palpites_existentes = [",".join(map(str, p)) for p in palpites]
        
        if palpite_str not in palpites_existentes:
            palpites.append(palpite)
    
    # Se n√£o conseguimos gerar palpites suficientes, retornar o que temosconst socketioU
    return palpites

def gerar_palpites_grande_quantidade(numeros_disponiveis, total_palpites):
    """
    M√©todo otimizado para gerar grandes quantidades de palpites.
    Usa um conjunto para verifica√ß√£o r√°pida de duplicatas.
    """
    palpites_set = set()
    palpites = []
    
    alta_variabilidade = len(numeros_disponiveis) >= 15
    
    max_tentativas = total_palpites * 5
    tentativas = 0
    
    while len(palpites) < total_palpites and tentativas < max_tentativas:
        tentativas += 1
        
        if alta_variabilidade:
            if len(numeros_disponiveis) >= 6:
                palpite = tuple(sorted(random.sample(numeros_disponiveis, 6)))
            else:
                numeros_base = list(numeros_disponiveis)
                complementos_necessarios = 6 - len(numeros_base)
                complementos = []
                
                while len(complementos) < complementos_necessarios:
                    num = random.randint(1, 60)
                    if num not in numeros_base and num not in complementos:
                        complementos.append(num)
                
                palpite = tuple(sorted(numeros_base + complementos))
        else:
            n_disponiveis = min(4, len(numeros_disponiveis))
            
            if n_disponiveis > 0:
                numeros_base = random.sample(numeros_disponiveis, n_disponiveis)
            else:
                numeros_base = []
                
            complementos = []
            while len(numeros_base) + len(complementos) < 6:
                num = random.randint(1, 60)
                if num not in numeros_base and num not in complementos:
                    complementos.append(num)
            
            palpite = tuple(sorted(numeros_base + complementos))
        
        if palpite not in palpites_set:
            palpites_set.add(palpite)
            palpites.append(list(palpite))
            
            # A cada 100 palpites, fazer uma pausa para diminuir a carga na CPU
            if len(palpites) % 100 == 0 and len(palpites) < total_palpites:
                time.sleep(0.01)
    
    return palpites

@app.route("/gerar_palpites", methods=["POST"])
def gerar_palpites():
    try:
        dados = request.get_json()
        if not dados:
            app.logger.error('Dados JSON n√£o recebidos ou inv√°lidos')
            return jsonify({"erro": "Dados JSON inv√°lidos ou n√£o fornecidos"}), 400
            
        combinacoes_formatadas = dados.get("combinacoes", [])
        total_palpites = int(dados.get("quantidade", 10))
        
        app.logger.info(f'Gerando {total_palpites} palpites para a Mega Sena.')
        
        # Valida√ß√£o
        if not combinacoes_formatadas or total_palpites <= 0:
            app.logger.warning('Dados de entrada para gera√ß√£o de palpites inv√°lidos')
            return jsonify({"erro": "Dados inv√°lidos"}), 400
        
        # Limitar o n√∫mero m√°ximo de palpites para evitar timeout
        max_palpites = 10000  # Ajuste conforme necess√°rio
        if total_palpites > max_palpites:
            app.logger.warning(f'Solicita√ß√£o de {total_palpites} palpites excede o limite de {max_palpites}')
            total_palpites = max_palpites
        
        # Definir timeout para evitar que o servidor fique bloqueado
        timeout_seconds = 30  # Ajuste conforme necess√°rio
        
        # Usar um timer para limitar o tempo de execu√ß√£o
        start_time = time.time()
        palpites = gerar_palpites_mega_sena(combinacoes_formatadas, total_palpites)
        execution_time = time.time() - start_time
        
        app.logger.info(f'Gerados {len(palpites)} palpites em {execution_time:.2f} segundos')
        
        return jsonify({"total": len(palpites), "palpites": palpites})
    
    except Exception as e:
        app.logger.error(f'Erro inesperado ao gerar palpites: {str(e)}')
        import traceback
        app.logger.error(traceback.format_exc())
        return jsonify({"erro": f"Erro inesperado: {str(e)}"}), 500
        
def validar_digitos_unicos(numeros_str):
    """
    Valida se a entrada cont√©m apenas d√≠gitos √∫nicos (0-9) separados por v√≠rgula.
    N√£o permite repeti√ß√£o de d√≠gitos.
    Retorna uma tupla (v√°lido, mensagem de erro).
    """
    # Remover espa√ßos em branco
    numeros_str = numeros_str.replace(" ", "")
    
    # Verificar se cont√©m apenas d√≠gitos e v√≠rgulas
    import re
    if not re.match(r'^[0-9,]*$', numeros_str):
        return False, "Entrada deve conter apenas d√≠gitos (0-9) e v√≠rgulas."
    
    # Verificar se cada elemento √© um √∫nico d√≠gito
    elementos = numeros_str.split(",")
    for elem in elementos:
        if elem and len(elem) > 1:
            return False, "Cada elemento deve ser um √∫nico d√≠gito (0-9)."
    
    # Verificar se h√° d√≠gitos duplicados
    digitos = [int(elem) for elem in elementos if elem]
    if len(digitos) != len(set(digitos)):
        return False, "N√£o √© permitido repetir d√≠gitos. Use cada d√≠gito apenas uma vez."
    
    # Verificar se todos os d√≠gitos est√£o no intervalo 0-9
    for digito in digitos:
        if digito < 0 or digito > 9:
            return False, "Apenas d√≠gitos entre 0 e 9 s√£o permitidos."
    
    return True, ""    
        

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 10000))
    app.run(host="0.0.0.0", port=port)
	
	# celery_config.py
from celery import Celery
import os

# Configura√ß√£o do Redis como broker e backend
# redis_url = os.environ.get('REDIS_URL', 'redis://localhost:6379/0')

# Configura√ß√£o do Redis como broker e backend
redis_url = os.environ.get('REDIS_URL', 'redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833')

# Inicializa√ß√£o do Celery
celery_app = Celery(
    'combinacoes',
    broker=redis_url,
    backend=redis_url,
    include=['celery_tasks']  # M√≥dulo onde as tarefas est√£o definidas
)

# Configura√ß√µes do Celery
celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='America/Sao_Paulo',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=3600,  # Limite de 1 hora por tarefa
    worker_max_tasks_per_child=10,  # Reinicia o worker ap√≥s 10 tarefas
    worker_prefetch_multiplier=4,  # Equilibra a carga entre workers
)

# Para iniciar o Celery, execute:
# celery -A celery_config worker --loglevel=info

# socketio_server.py
import os
import json
import redis
import threading
from flask import Flask, request
from flask_socketio import SocketIO
import logging
from dotenv import load_dotenv, find_dotenv

# Carregar vari√°veis de ambiente do arquivo .env
dotenv_path = find_dotenv()
if dotenv_path:
    load_dotenv(dotenv_path)

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configura√ß√£o do Redis
# redis_url = os.environ.get('REDIS_URL', 'redis://localhost:6379/0')
# redis_client = redis.Redis.from_url(redis_url, decode_responses=True)

# Configura√ß√£o do Redis
redis_url = os.environ.get('REDIS_URL', 'redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833')
redis_client = redis.Redis.from_url(redis_url, decode_responses=True)

# Inicializa√ß√£o do Flask e Socket.IO
app = Flask(__name__)

# Ao configurar o SocketIO, modifique para:
socketio = SocketIO(
    app, 
    cors_allowed_origins=["*"],  # Permitir todas as origens durante desenvolvimento
    async_mode='eventlet',
    logger=True,  # Ativar logs para identificar problemas
    engineio_logger=True
)

# Thread para escutar mensagens do Redis
def redis_listener():
    """
    Ouve mensagens de progresso no Redis e as envia para os clientes via Socket.IO
    """
    pubsub = redis_client.pubsub()
    # Inscrever-se em todos os canais de progresso de tarefas
    pubsub.psubscribe('task_progress:*')
    
    logger.info("Iniciando thread de escuta do Redis")
    
    for message in pubsub.listen():
        try:
            if message['type'] == 'pmessage':
                # Extrair o ID da tarefa do canal
                channel = message['channel']
                task_id = channel.split(':')[1]
                
                # Analisar a mensagem JSON
                data = json.loads(message['data'])
                
                # Enviar para os clientes inscritos nesta tarefa
                logger.info(f"Enviando atualiza√ß√£o para tarefa {task_id}: {data['status']}")
                socketio.emit(f'task_update:{task_id}', data)
        except Exception as e:
            logger.error(f"Erro no processamento de mensagem Redis: {str(e)}")

# Iniciar a thread do Redis na inicializa√ß√£o
@socketio.on('connect')
def handle_connect():
    logger.info(f"Cliente conectado: {request.sid}")

@socketio.on('subscribe')
def handle_subscribe(data):
    """
    Cliente se inscreve para receber atualiza√ß√µes de uma tarefa espec√≠fica
    """
    task_id = data.get('task_id')
    if not task_id:
        return {'error': 'ID da tarefa n√£o fornecido'}
    
    logger.info(f"Cliente {request.sid} inscrito na tarefa {task_id}")
    
    # Verificar se j√° temos o resultado armazenado
    result_key = f'task_result:{task_id}'
    stored_result = redis_client.get(result_key)
    
    if stored_result:
        # A tarefa j√° foi conclu√≠da, enviar o resultado imediatamente
        result_data = json.loads(stored_result)
        socketio.emit(f'task_update:{task_id}', {
            'status': 'completed',
            'progress': 100,
            'result': result_data
        }, room=request.sid)
        return {'success': True, 'message': 'Resultado j√° dispon√≠vel'}
    
    return {'success': True, 'message': 'Inscrito para atualiza√ß√µes'}

# Iniciar a thread do Redis
redis_thread = threading.Thread(target=redis_listener, daemon=True)
redis_thread.start()

if __name__ == '__main__':
    port = int(os.environ.get("SOCKETIO_PORT", 10001))
    logger.info(f"Iniciando servidor Socket.IO na porta {port}")
    socketio.run(app, host='0.0.0.0', port=port, debug=True)
	
	#redis_config.py

import os
from dotenv import load_dotenv, find_dotenv

# Carrega vari√°veis de ambiente
dotenv_path = find_dotenv()
if dotenv_path:
    load_dotenv(dotenv_path)

# URL do Redis (usar a mesma em todos os componentes)
# REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")

# URL do Redis (usar a mesma em todos os componentes)
REDIS_URL = os.getenv('REDIS_URL', 'redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833')

#paraleliza√ß√£o.py
import multiprocessing
import numpy as np
from concurrent.futures import ProcessPoolExecutor, as_completed
import time
import os
import logging

def gerar_palpites_chunk(args):
    """
    Fun√ß√£o para gerar um chunk de palpites, ser√° chamada por cada processo
    
    Args:
        args (tuple): (chunk_id, numeros_disponiveis, quantidade_no_chunk, seed)
        
    Returns:
        list: Lista de palpites gerados neste chunk
    """
    chunk_id, numeros_disponiveis, quantidade, seed = args
    
    # Definir uma semente para reprodutibilidade, mas diferente para cada chunk
    np.random.seed(seed + chunk_id)
    import random
    random.seed(seed + chunk_id)
    
    # Usar uma fun√ß√£o existente para gerar palpites
    # Podemos usar a fun√ß√£o gospers_hack ou qualquer outra otimizada
    palpites = gerar_palpites_mega_sena_gosper(numeros_disponiveis, quantidade)
    
    return palpites

def gerar_palpites_paralelo(numeros_disponiveis, total_palpites, max_workers=None):
    """
    Gera palpites de forma paralela, dividindo o trabalho em m√∫ltiplos processos
    
    Args:
        numeros_disponiveis (list): Lista de n√∫meros dispon√≠veis para formar palpites
        total_palpites (int): N√∫mero total de palpites a serem gerados
        max_workers (int, optional): N√∫mero m√°ximo de processos, padr√£o √© None (usa CPUs dispon√≠veis)
        
    Returns:
        list: Lista de palpites, onde cada palpite √© uma lista de 6 n√∫meros
    """
    import time
    inicio = time.time()
    
    # Determinar n√∫mero de processos
    if max_workers is None:
        max_workers = max(1, multiprocessing.cpu_count() - 1)  # Deixar 1 CPU livre
    
    # Dividir o trabalho em chunks
    chunks = min(max_workers, total_palpites)
    palpites_por_chunk = [total_palpites // chunks] * chunks
    
    # Distribuir o restante
    resto = total_palpites % chunks
    for i in range(resto):
        palpites_por_chunk[i] += 1
    
    # Preparar argumentos para cada processo
    seed = int(time.time())
    args_list = [
        (i, numeros_disponiveis, palpites_por_chunk[i], seed) 
        for i in range(chunks)
    ]
    
    # Usar ProcessPoolExecutor para processamento paralelo
    palpites_resultado = []
    with ProcessPoolExecutor(max_workers=max_workers) as executor:
        # Submeter tarefas
        futures = [executor.submit(gerar_palpites_chunk, args) for args in args_list]
        
        # Coletar resultados √† medida que eles s√£o conclu√≠dos
        for future in as_completed(futures):
            try:
                # Adicionar palpites deste chunk ao resultado
                palpites_chunk = future.result()
                palpites_resultado.extend(palpites_chunk)
            except Exception as e:
                logging.error(f"Erro no processamento de um chunk: {e}")
    
    # Remover poss√≠veis duplicatas (pode acontecer entre chunks)
    palpites_unicos = []
    palpites_set = set()
    
    for palpite in palpites_resultado:
        palpite_tuple = tuple(palpite)
        if palpite_tuple not in palpites_set:
            palpites_set.add(palpite_tuple)
            palpites_unicos.append(palpite)
    
    # Limitar ao total solicitado (pode haver excesso devido √† divis√£o em chunks)
    palpites_finais = palpites_unicos[:total_palpites]
    
    fim = time.time()
    logging.info(f"Gerados {len(palpites_finais)} palpites em {fim - inicio:.2f} segundos usando {chunks} processos")
    
    return palpites_finais

# Implementar no endpoint Flask
def integrar_na_app(app):
    """
    Integra as fun√ß√µes paralelas na aplica√ß√£o Flask
    """
    @app.route("/gerar_palpites_paralelo", methods=["POST"])
    def gerar_palpites_endpoint():
        try:
            dados = request.get_json()
            combinacoes_formatadas = dados.get("combinacoes", [])
            total_palpites = int(dados.get("quantidade", 10))
            
            app.logger.info(f'Gerando {total_palpites} palpites para a Mega Sena usando paraleliza√ß√£o.')
            
            # Valida√ß√£o
            if not combinacoes_formatadas or total_palpites <= 0:
                app.logger.warning('Dados de entrada para gera√ß√£o de palpites inv√°lidos')
                return jsonify({"erro": "Dados inv√°lidos"}), 400
            
            # Usar a fun√ß√£o de extra√ß√£o de n√∫meros existente
            numeros_unicos = set()
            for combinacao in combinacoes_formatadas:
                i = 0
                while i < len(combinacao):
                    if i + 1 < len(combinacao):
                        try:
                            num_str = combinacao[i:i+2]
                            numero = int(num_str)
                            if 1 <= numero <= 60:
                                numeros_unicos.add(numero)
                        except ValueError:
                            pass
                    i += 2
            
            numeros_disponiveis = list(numeros_unicos)
            
            # Se n√£o houver n√∫meros suficientes, complementar
            if len(numeros_disponiveis) < 6:
                import random
                numeros_faltantes = set(range(1, 61)) - set(numeros_disponiveis)
                numeros_complementares = random.sample(list(numeros_faltantes), 6 - len(numeros_disponiveis))
                numeros_disponiveis.extend(numeros_complementares)
            
            # Gerar palpites usando paraleliza√ß√£o
            palpites = gerar_palpites_paralelo(numeros_disponiveis, total_palpites)
            
            app.logger.info(f'Gerados {len(palpites)} palpites em paralelo')
            
            return jsonify({"total": len(palpites), "palpites": palpites})
        
        except Exception as e:
            app.logger.error(f'Erro inesperado ao gerar palpites: {str(e)}')
            return jsonify({"erro": f"Erro inesperado: {str(e)}"}), 500
			
			#gospers_hack.py

def gospers_hack(k, n):
    """
    Algoritmo de Gosper's Hack para gerar combina√ß√µes de k elementos de um conjunto de n elementos.
    Esta implementa√ß√£o √© extremamente eficiente para grandes conjuntos.
    
    Args:
        k (int): Tamanho da combina√ß√£o
        n (int): Tamanho do conjunto
    
    Yields:
        list: Cada combina√ß√£o como uma lista de √≠ndices
    """
    # Valor inicial: os k primeiros bits est√£o ligados
    mask = (1 << k) - 1
    
    while mask < (1 << n):
        # Converter bits para lista de √≠ndices
        yield [i for i in range(n) if (mask & (1 << i))]
        
        # Pr√≥xima combina√ß√£o lexicogr√°fica usando manipula√ß√£o de bits
        c = mask & -mask
        r = mask + c
        mask = (((r ^ mask) >> 2) // c) | r

# Fun√ß√£o para gerar palpites usando Gosper's Hack
def gerar_palpites_mega_sena_gosper(numeros_disponiveis, total_palpites):
    """
    Gera palpites para a Mega Sena usando o algoritmo de Gosper's Hack.
    
    Args:
        numeros_disponiveis (list): Lista de n√∫meros dispon√≠veis para formar palpites
        total_palpites (int): N√∫mero de palpites a serem gerados
        
    Returns:
        list: Lista de palpites, onde cada palpite √© uma lista de 6 n√∫meros
    """
    import random
    
    n = len(numeros_disponiveis)
    if n < 6:
        # N√£o temos n√∫meros suficientes, precisamos complementar
        raise ValueError("N√∫mero insuficiente de n√∫meros dispon√≠veis")
    
    palpites = []
    palpites_set = set()  # Para verifica√ß√£o r√°pida de duplicatas
    
    # Se temos muitos n√∫meros, vamos usar uma abordagem mais eficiente
    if n > 60:  # N√∫mero grande de possibilidades
        # Vamos tentar gerar aleatoriamente os primeiros palpites
        for _ in range(min(total_palpites, 1000)):  # Limitamos a 1000 tentativas aleat√≥rias
            indices = sorted(random.sample(range(n), 6))
            palpite = tuple(sorted(numeros_disponiveis[i] for i in indices))
            
            if palpite not in palpites_set:
                palpites_set.add(palpite)
                palpites.append(list(palpite))
                
                if len(palpites) >= total_palpites:
                    return palpites
        
        # Se ainda precisamos de mais palpites, usamos Gosper's Hack
        if len(palpites) < total_palpites:
            # Embaralhar para diversidade
            indices = list(range(n))
            random.shuffle(indices)
            numeros_permutados = [numeros_disponiveis[i] for i in indices]
            
            # Gerar combina√ß√µes usando Gosper's Hack
            for combo_indices in gospers_hack(6, min(n, 50)):  # Limitamos a 50 elementos para efici√™ncia
                palpite = tuple(sorted(numeros_permutados[i] for i in combo_indices))
                
                if palpite not in palpites_set:
                    palpites_set.add(palpite)
                    palpites.append(list(palpite))
                    
                    if len(palpites) >= total_palpites:
                        return palpites
    else:
        # Para conjuntos menores, Gosper's Hack √© ideal
        all_combinations = list(gospers_hack(6, n))
        random.shuffle(all_combinations)  # Embaralhar para diversidade
        
        for combo_indices in all_combinations:
            palpite = tuple(sorted(numeros_disponiveis[i] for i in combo_indices))
            
            if palpite not in palpites_set:
                palpites_set.add(palpite)
                palpites.append(list(palpite))
                
                if len(palpites) >= total_palpites:
                    break
    
    return palpites
	
# celery_tasks.py
import time
import random
import logging
from celery import Task
from celery.utils.log import get_task_logger
from celery_config import celery_app
import redis
import json

# Configurar o logger
logger = get_task_logger(__name__)

# Configura√ß√£o do Redis para comunica√ß√£o em tempo real
redis_client = redis.Redis.from_url(
    celery_app.conf.broker_url, 
    decode_responses=True
)

# Importar as fun√ß√µes de gera√ß√£o otimizadas
from gospers_hack import gerar_palpites_mega_sena_gosper
from paralelizacao import gerar_palpites_paralelo

class PaleitosTask(Task):
    """Classe base personalizada para tarefas de gera√ß√£o de palpites que rastreia o progresso"""
    
    def on_success(self, retval, task_id, args, kwargs):
        """Chamado quando a tarefa √© conclu√≠da com sucesso"""
        # Atualizar o canal Redis com status de conclus√£o
        redis_client.publish(
            f'task_progress:{task_id}',
            json.dumps({
                'status': 'completed',
                'progress': 100,
                'total_gerado': retval.get('total', 0)
            })
        )
        # Armazenar o resultado por 1 hora (3600 segundos)
        redis_client.setex(
            f'task_result:{task_id}',
            3600,
            json.dumps(retval)
        )
        return super().on_success(retval, task_id, args, kwargs)
    
    def on_failure(self, exc, task_id, args, kwargs, einfo):
        """Chamado quando a tarefa falha"""
        # Atualizar o canal Redis com status de falha
        redis_client.publish(
            f'task_progress:{task_id}',
            json.dumps({
                'status': 'failed',
                'error': str(exc)
            })
        )
        return super().on_failure(exc, task_id, args, kwargs, einfo)

@celery_app.task(bind=True, base=PaleitosTask)
def gerar_palpites_tarefa(self, combinacoes_formatadas, total_palpites):
    """
    Tarefa Celery para gerar palpites da Mega Sena em segundo plano
    com atualiza√ß√µes de progresso em tempo real
    """
    task_id = self.request.id
    
    try:
        logger.info(f'Iniciando gera√ß√£o de {total_palpites} palpites. Task ID: {task_id}')
        
        # Publicar status inicial
        redis_client.publish(
            f'task_progress:{task_id}',
            json.dumps({
                'status': 'started',
                'progress': 0,
                'total_solicitado': total_palpites
            })
        )
        
        # Extrair n√∫meros das combina√ß√µes
        numeros_unicos = set()
        for combinacao in combinacoes_formatadas:
            i = 0
            while i < len(combinacao):
                if i + 1 < len(combinacao):
                    try:
                        num_str = combinacao[i:i+2]
                        numero = int(num_str)
                        if 1 <= numero <= 60:
                            numeros_unicos.add(numero)
                    except ValueError:
                        pass
                i += 2
        
        numeros_disponiveis = list(numeros_unicos)
        
        # Publicar progresso de processamento de dados
        redis_client.publish(
            f'task_progress:{task_id}',
            json.dumps({
                'status': 'processing',
                'progress': 10,
                'message': f'Encontrados {len(numeros_disponiveis)} n√∫meros √∫nicos'
            })
        )
        
        # Complementar se necess√°rio
        if len(numeros_disponiveis) < 6:
            numeros_faltantes = set(range(1, 61)) - set(numeros_disponiveis)
            numeros_complementares = random.sample(list(numeros_faltantes), 6 - len(numeros_disponiveis))
            numeros_disponiveis.extend(numeros_complementares)
        
        # Para grandes quantidades, dividir o processamento em blocos com atualiza√ß√µes de progresso
        if total_palpites > 1000:
            palpites = []
            blocos = min(10, total_palpites // 100)  # Dividir em at√© 10 blocos
            palpites_por_bloco = total_palpites // blocos
            
            for i in range(blocos):
                # Gerar este bloco de palpites
                inicio_bloco = time.time()
                
                if i == blocos - 1:
                    # √öltimo bloco pega o resto
                    qtd_bloco = total_palpites - len(palpites)
                else:
                    qtd_bloco = palpites_por_bloco
                
                # Usar paraleliza√ß√£o para este bloco
                palpites_bloco = gerar_palpites_paralelo(
                    numeros_disponiveis, 
                    qtd_bloco
                )
                
                # Adicionar ao resultado total
                palpites.extend(palpites_bloco)
                
                # Calcular e publicar progresso
                progresso = min(95, 10 + (85 * (i + 1) // blocos))
                redis_client.publish(
                    f'task_progress:{task_id}',
                    json.dumps({
                        'status': 'processing',
                        'progress': progresso,
                        'current': len(palpites),
                        'total': total_palpites,
                        'message': f'Gerados {len(palpites)} de {total_palpites} palpites'
                    })
                )
                
                logger.info(f'Bloco {i+1}/{blocos}: Gerados {len(palpites_bloco)} palpites em {time.time() - inicio_bloco:.2f} segundos')
        else:
            # Para quantidades menores, fazer tudo de uma vez
            palpites = gerar_palpites_mega_sena_gosper(numeros_disponiveis, total_palpites)
            
            # Publicar progresso
            redis_client.publish(
                f'task_progress:{task_id}',
                json.dumps({
                    'status': 'processing',
                    'progress': 90,
                    'current': len(palpites),
                    'total': total_palpites
                })
            )
        
        # Garantir que temos exatamente o n√∫mero solicitado
        palpites = palpites[:total_palpites]
        
        # Preparar o resultado final
        resultado = {
            "total": len(palpites),
            "palpites": palpites
        }
        
        # Armazenar o resultado no Redis por 1 hora
        redis_client.setex(
            f'task_result:{task_id}',
            3600,  # 1 hora
            json.dumps(resultado)
        )
        
        logger.info(f'Conclu√≠da gera√ß√£o de {len(palpites)} palpites. Task ID: {task_id}')
        
        return resultado
        
    except Exception as e:
        logger.error(f'Erro na gera√ß√£o de palpites: {str(e)}')
        # Publicar erro
        redis_client.publish(
            f'task_progress:{task_id}',
            json.dumps({
                'status': 'error',
                'message': str(e)
            })
        )
        raise  # Relan√ßar para o Celery lidar



// websocket.js
// Gerenciamento de conex√£o WebSocket e atualiza√ß√µes de progresso
let socket = null;
let currentTaskId = null;

// Inicializar Socket.IO
function initSocketIO(socketioUrl) {
    if (socket) return; // J√° inicializado
    
    try {
        socket = io(socketioUrl);
        
        socket.on('connect', () => {
            console.log('Conectado ao servidor Socket.IO');
            if (currentTaskId) {
                subscribeToTask(currentTaskId);
            }
        });
        
        socket.on('connect_error', (error) => {
            console.error('Erro de conex√£o Socket.IO:', error);
            mostrarErroConexao();
        });
    } catch (e) {
        console.error('Erro ao inicializar Socket.IO:', e);
        mostrarErroConexao();
    }
}

// Inscrever-se para atualiza√ß√µes de uma tarefa
function subscribeToTask(taskId) {
    if (!socket) return false;
    
    currentTaskId = taskId;
    
    // Inscrever-se no canal desta tarefa
    socket.emit('subscribe', { task_id: taskId });
    
    // Definir o manipulador de eventos para esta tarefa
    socket.on(`task_update:${taskId}`, (data) => {
        atualizarProgressoTarefa(data);
    });
    
    return true;
}

// Atualizar a interface com o progresso da tarefa
function atualizarProgressoTarefa(data) {
    console.log('Atualiza√ß√£o de tarefa:', data);
    
    const progressBar = document.getElementById('progressoTarefa');
    const statusMsg = document.getElementById('statusTarefa');
    const mensagemTarefa = document.getElementById('mensagemTarefa');
    const btnNovo = document.getElementById('btnNovoProcessamento');
    
    // Atualizar a barra de progresso
    if (progressBar) {
        progressBar.style.width = `${data.progress || 0}%`;
        progressBar.setAttribute('aria-valuenow', data.progress || 0);
    }
    
    // Atualizar mensagem de status
    if (statusMsg) {
        if (data.message) {
            statusMsg.textContent = data.message;
        } else if (data.status === 'completed') {
            statusMsg.textContent = `Processamento conclu√≠do! Gerados ${data.total_gerado} palpites.`;
            
            // Mostrar os resultados
            processarResultadoPalpites(data.result);
            
            // Mostrar bot√£o para novo processamento
            if (btnNovo) btnNovo.style.display = 'inline-block';
            
            // Atualizar classe da mensagem
            if (mensagemTarefa) mensagemTarefa.className = 'alert alert-success';
        } else if (data.status === 'processing') {
            if (data.current && data.total) {
                statusMsg.textContent = `Processando: ${data.current} de ${data.total} palpites (${data.progress}%)`;
            } else {
                statusMsg.textContent = `Processando... (${data.progress}%)`;
            }
        } else if (data.status === 'failed' || data.status === 'error') {
            statusMsg.textContent = `Erro: ${data.error || 'Ocorreu um erro durante o processamento.'}`;
            
            // Atualizar classe da mensagem
            if (mensagemTarefa) mensagemTarefa.className = 'alert alert-danger';
            
            // Mostrar bot√£o para novo processamento
            if (btnNovo) btnNovo.style.display = 'inline-block';
        }
    }
}

// Fun√ß√£o para mostrar erro de conex√£o
function mostrarErroConexao() {
    const mensagemTarefa = document.getElementById('mensagemTarefa');
    if (mensagemTarefa) {
        mensagemTarefa.className = 'alert alert-danger';
        mensagemTarefa.innerHTML = 'Erro de conex√£o com o servidor de atualiza√ß√µes em tempo real.';
    }
}

// Processar o resultado dos palpites e exibi-los
function processarResultadoPalpites(resultado) {
    if (!resultado || !resultado.palpites) return;
    
    const palpitesDiv = document.getElementById('palpites');
    if (!palpitesDiv) return;
    
    // Atualizar o total de palpites
    document.getElementById('totalPalpites').textContent = resultado.total;
    
    // Exibir os palpites em uma tabela
    const table = document.createElement("table");
    table.className = "table table-striped";
    
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    
    // Cabe√ßalho numerado de 1 a 6
    for (let i = 1; i <= 6; i++) {
        const th = document.createElement("th");
        th.textContent = `N¬∫ ${i}`;
        headerRow.appendChild(th);
    }
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    const tbody = document.createElement("tbody");
    
    // Adicionar cada palpite como uma linha
    resultado.palpites.forEach((palpite) => {
        const row = document.createElement("tr");
        
        // Cada n√∫mero do palpite em uma c√©lula
        palpite.forEach(numero => {
            const cell = document.createElement("td");
            cell.textContent = numero;
            row.appendChild(cell);
        });
        
        tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    palpitesDiv.innerHTML = '';
    palpitesDiv.appendChild(table);
    
    // Exibir o card de palpites
    document.getElementById("palpitesCard").style.display = "block";
    
    // Esconder o processamento ass√≠ncrono depois de um tempo
    setTimeout(() => {
        document.getElementById("processamentoAssincrono").style.display = "none";
    }, 5000);
}

//websocket_connect.js
// Fun√ß√£o para conectar ao Socket.IO com tratamento de erros
function connectWebSocket(socketUrl) {
    try {
        console.log("Tentando conectar ao Socket.IO:", socketUrl);
        const socket = io(socketUrl, {
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            timeout: 20000
        });

        socket.on('connect', function() {
            console.log('Conectado ao servidor Socket.IO!');
        });

        socket.on('connect_error', function(error) {
            console.error('Erro na conex√£o Socket.IO:', error);
        });

        socket.on('disconnect', function() {
            console.log('Desconectado do servidor Socket.IO');
        });

        return socket;
    } catch (e) {
        console.error("Erro ao inicializar Socket.IO:", e);
        return null;
    }
}
// scripts.js
// Fun√ß√£o para formatar n√∫mero no padr√£o brasileiro
function formatarNumeroParaBR(numero) {
    return numero.toLocaleString('pt-BR');
  }


// Inicializar a valida√ß√£o quando o documento estiver carregado
document.addEventListener("DOMContentLoaded", function() {
    validarEntradaDigitos();
    
    // Tamb√©m adicionar mensagem de instru√ß√£o inicial
    const inputDigitos = document.getElementById("numeros");
    inputDigitos.setAttribute("placeholder", "ex: 0,1,2,3,4,5,6");
    
    // Exibir a div de erro (inicialmente escondida)
    const errorDiv = document.getElementById("numerosError");
    if (!errorDiv) {
        // Se n√£o existir, criar a div
        const div = document.createElement("div");
        div.id = "numerosError";
        div.className = "error-message";
        inputDigitos.parentNode.insertBefore(div, inputDigitos.nextSibling);
    }
});

// Fun√ß√£o para calcular o n√∫mero total de combina√ß√µes poss√≠veis
function calcularTotalCombinacoesPossiveis(n, r) {
  // Fun√ß√£o para calcular fatorial (limita a n√∫meros menores para evitar overflow)
  function fatorial(num) {
    if (num <= 1) return 1;
    let resultado = 1;
    for (let i = 2; i <= num; i++) {
      resultado *= i;
    }
    return resultado;
  }
  
  // Para n√∫meros grandes, usamos uma abordagem mais eficiente
  function calcularCombinacaoGrande(n, r) {
    let resultado = 1;
    // Calcular n! / (n-r)! diretamente
    for (let i = n - r + 1; i <= n; i++) {
      resultado *= i;
    }
    // Dividir por r!
    resultado /= fatorial(r);
    return Math.floor(resultado);
  }
  
  if (n < r) return 0;
  
  // Usar m√©todo apropriado baseado no tamanho dos n√∫meros
  if (n > 20) {
    return calcularCombinacaoGrande(n, r);
  } else {
    return Math.floor(fatorial(n) / (fatorial(r) * fatorial(n - r)));
  }
}

// Fun√ß√£o auxiliar para extrair n√∫meros da lista de combina√ß√µes formatadas
function extrairNumerosUnicos(combinacoes) {
  const numerosUnicos = new Set();
  
  for (const combinacao of combinacoes) {
    // Tentar extrair n√∫meros de 2 d√≠gitos da combina√ß√£o
    let i = 0;
    while (i < combinacao.length) {
      if (i + 1 < combinacao.length) {
        try {
          const numStr = combinacao.substring(i, i+2);
          const numero = parseInt(numStr);
          if (numero >= 1 && numero <= 60) {
            numerosUnicos.add(numero);
          }
        } catch (e) {}
      }
      i += 2;
    }
  }
  
  return [...numerosUnicos];
}

// Fun√ß√£o para calcular combina√ß√µes
// Fun√ß√£o atualizada para calcular combina√ß√µes
// async function calcularCombinacoes(event) {
//     event.preventDefault();
    
//     const numeros = document.getElementById("numeros").value;
//     const tamanho = document.getElementById("tamanho").value;
    
//     try {
//         const response = await fetch("/calcular", {
//             method: "POST",
//             headers: {
//                 "Content-Type": "application/json"
//             },
//             body: JSON.stringify({ numeros, tamanho })
//         });
        
//         const data = await response.json();
        
//         if (response.ok) {
//             // Filtrar novamente para garantir que n√£o exibimos n√∫meros acima de 60
//             const combinacoesFiltradas = data.combinacoes.filter(comb => {
//                 const num = parseInt(comb);
//                 return num > 0 && num <= 60;
//             });
            
//             // Exibe o total ap√≥s filtragem
//             document.getElementById("totalCombinacoes").style.display = "block";
//             document.getElementById("total").textContent = combinacoesFiltradas.length;
            
//             // Exibe as combina√ß√µes no formato de tabela para Excel
//             const combinacoesDiv = document.getElementById("combinacoes");
//             combinacoesDiv.innerHTML = "";
            
//             // Usar a fun√ß√£o para criar a tabela formatada para Excel
//             const tabela = criarTabelaCombinacoes(combinacoesFiltradas);
//             combinacoesDiv.appendChild(tabela);
            
//             document.getElementById("resultadoCard").style.display = "block";
            
//             // Armazenar as combina√ß√µes filtradas para uso posterior
//             window.combinacoesGeradas = combinacoesFiltradas;
            
//             // Verificar se deve mostrar os controles de palpites
//             const digitosInput = document.getElementById("numeros").value;
//             const digitos = digitosInput.split(",").map(d => d.trim()).filter(d => d);
//             const quantidadeDigitos = digitos.length;
            
//             // Mostrar controles apenas se tivermos 4 ou mais d√≠gitos
//             const palpitesControle = document.getElementById("palpitesControle");
//             if (quantidadeDigitos >= 4 && combinacoesFiltradas.length >= 12) {
//                 palpitesControle.style.display = "block";
                
//                 // Calcular o total te√≥rico de palpites poss√≠veis
//                 // Primeiro extrair os n√∫meros √∫nicos das combina√ß√µes geradas
//                 const numerosUnicosArray = extrairNumerosUnicos(combinacoesFiltradas);
//                 console.log("N√∫meros √∫nicos extra√≠dos:", numerosUnicosArray);
                
//                 // Filtrar n√∫meros maiores que 60 (limite da Mega Sena)
//                 const numerosFiltrados = numerosUnicosArray.filter(n => n <= 60);
                
//                 const totalTeorico = calcularTotalCombinacoesPossiveis(numerosFiltrados.length, 6);
//                 console.log("Total te√≥rico calculado:", totalTeorico);
                
//                 // Mostrar o total te√≥rico na interface
//                 document.getElementById("totalTeorico").textContent = totalTeorico.toLocaleString('pt-BR');
                
//                 // Ajustar o range para o total te√≥rico (com limite pr√°tico de 1000 para n√£o travar a interface)
                
// 				//	const limiteMaximo = Math.min(1000, Math.max(1, totalTeorico));
// 					const limiteMaximo = Math.max(1, totalTeorico);
//                 const rangeInput = document.getElementById("quantidadePalpites");
//                 rangeInput.max = limiteMaximo;
//                 rangeInput.value = Math.min(10, limiteMaximo);
//                 document.getElementById("valorQuantidadePalpites").textContent = rangeInput.value;
                
//                 // Atualizar o texto do m√°ximo
//                 document.getElementById("valorMaximo").textContent = limiteMaximo.toLocaleString('pt-BR');
//             } else {
//                 palpitesControle.style.display = "none";
//                 // Esconder o container de palpites caso esteja vis√≠vel
//                 document.getElementById("palpitesCard").style.display = "none";
//             }
//         } else {
//             alert(data.erro || "Erro ao calcular combina√ß√µes");
//         }
//     } catch (error) {
//         alert("Erro ao comunicar com o servidor");
//         console.error(error);
//     }
// }


// Fun√ß√£o para calcular combina√ß√µes
async function calcularCombinacoes(event) {
    event.preventDefault();
    
    const numeros = document.getElementById("numeros").value;
    const tamanho = document.getElementById("tamanho").value;
    
    try {
        const response = await fetch("/calcular", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ numeros, tamanho })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // Exibe o total
            document.getElementById("totalCombinacoes").style.display = "block";
            document.getElementById("total").textContent = data.total;
            
            // Exibe as combina√ß√µes
            const combinacoesDiv = document.getElementById("combinacoes");
            combinacoesDiv.innerHTML = data.combinacoes.join(" ");
            document.getElementById("resultadoCard").style.display = "block";
            
            // Armazenar as combina√ß√µes para uso posterior
            window.combinacoesGeradas = data.combinacoes;
            
            // Verificar se deve mostrar os controles de palpites
            const digitosInput = document.getElementById("numeros").value;
            const digitos = digitosInput.split(",").map(d => d.trim()).filter(d => d);
            const quantidadeDigitos = digitos.length;
            
            // Mostrar controles apenas se tivermos 4 ou mais d√≠gitos
            const palpitesControle = document.getElementById("palpitesControle");
            if (quantidadeDigitos >= 4 && data.total >= 12) {
                palpitesControle.style.display = "block";
                
                // Calcular o total te√≥rico de palpites poss√≠veis
                // Primeiro extrair os n√∫meros √∫nicos das combina√ß√µes geradas
                const numerosUnicosArray = extrairNumerosUnicos(data.combinacoes);
                console.log("N√∫meros √∫nicos extra√≠dos:", numerosUnicosArray);
                
                const totalTeorico = calcularTotalCombinacoesPossiveis(numerosUnicosArray.length, 6);
                console.log("Total te√≥rico calculado:", totalTeorico);
                
                // Mostrar o total te√≥rico na interface formatado no padr√£o brasileiro
                document.getElementById("totalTeorico").textContent = formatarNumeroParaBR(totalTeorico);
                
                // ALTERA√á√ÉO AQUI: Usar totalTeorico como limite m√°ximo sem restri√ß√£o de 1000
                const limiteMaximo = Math.max(1, totalTeorico);
                const rangeInput = document.getElementById("quantidadePalpites");
                rangeInput.max = limiteMaximo;
                rangeInput.value = Math.min(10, limiteMaximo);
                document.getElementById("valorQuantidadePalpites").textContent = formatarNumeroParaBR(parseInt(rangeInput.value));
                
                // Atualizar o texto do m√°ximo formatado no padr√£o brasileiro
                document.getElementById("valorMaximo").textContent = formatarNumeroParaBR(limiteMaximo);
            } else {
                palpitesControle.style.display = "none";
                // Esconder o container de palpites caso esteja vis√≠vel
                document.getElementById("palpitesCard").style.display = "none";
            }
        } else {
            alert(data.erro || "Erro ao calcular combina√ß√µes");
        }
    } catch (error) {
        alert("Erro ao comunicar com o servidor");
        console.error(error);
    }
}
async function gerarPalpitesMegaSena() {
    // Verificar se temos combina√ß√µes geradas
    if (!window.combinacoesGeradas || window.combinacoesGeradas.length === 0) {
        alert("Por favor, gere as combina√ß√µes primeiro.");
        return;
    }
    
    // Obter a quantidade desejada de palpites
    const quantidadePalpites = parseInt(document.getElementById("quantidadePalpites").value);
    
    // Mostrar um indicador de carregamento para grandes quantidades
    if (quantidadePalpites > 50) {
        document.getElementById("palpitesCard").style.display = "block";
        document.getElementById("palpites").innerHTML = 
            `<div class="alert alert-info">
                <div class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
                Gerando ${quantidadePalpites} palpites. Isso pode levar alguns segundos...
            </div>`;
    }
    
    try {
        // Adicionar um timeout maior para a requisi√ß√£o
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 60000); // 60 segundos de timeout
        
        const response = await fetch("/gerar_palpites", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ 
                combinacoes: window.combinacoesGeradas,
                quantidade: quantidadePalpites
            }),
            signal: controller.signal
        });
        
        clearTimeout(timeoutId); // Limpar o timeout se a requisi√ß√£o completar antes
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error("Erro na resposta:", response.status, errorText);
            throw new Error(`Erro do servidor: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Exibe o total de palpites
        document.getElementById("totalPalpites").textContent = data.total;
        
        // Exibe os palpites
        const palpitesDiv = document.getElementById("palpites");
        palpitesDiv.innerHTML = "";
        
        // Criando tabela de palpites
        const table = document.createElement("table");
        table.className = "table table-striped";
        
        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");
        
        // Cabe√ßalho numerado de 1 a 6
        for (let i = 1; i <= 6; i++) {
            const th = document.createElement("th");
            th.textContent = `N¬∫ ${i}`;
            headerRow.appendChild(th);
        }
        
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        const tbody = document.createElement("tbody");
        
        // Adicionar cada palpite como uma linha
        data.palpites.forEach((palpite, index) => {
            const row = document.createElement("tr");
            
            // Cada n√∫mero do palpite em uma c√©lula
            palpite.forEach(numero => {
                const cell = document.createElement("td");
                cell.textContent = numero;
                row.appendChild(cell);
            });
            
            tbody.appendChild(row);
        });
        
        table.appendChild(tbody);
        palpitesDiv.appendChild(table);
        
        // Exibe o card de palpites
        document.getElementById("palpitesCard").style.display = "block";
    } catch (error) {
        console.error("Erro completo:", error);
        
        // Mostrar uma mensagem de erro mais informativa
        const palpitesDiv = document.getElementById("palpites");
        palpitesDiv.innerHTML = `
            <div class="alert alert-danger">
                <strong>Erro ao gerar palpites:</strong> ${error.message || 'Erro de comunica√ß√£o com o servidor'}
                <hr>
                <small>Tente reduzir o n√∫mero de palpites solicitados ou tente novamente mais tarde.</small>
            </div>
        `;
        
        document.getElementById("palpitesCard").style.display = "block";
    }
}
// // Adicione este event listener para atualizar o valor exibido do slider
// document.addEventListener("DOMContentLoaded", function() {
//     const rangeInput = document.getElementById("quantidadePalpites");
//     const valorSpan = document.getElementById("valorQuantidadePalpites");
    
//     if (rangeInput && valorSpan) {
//         rangeInput.addEventListener("input", function() {
//             valorSpan.textContent = this.value;
//         });
//     }
// });

// Adicione este event listener para atualizar o valor exibido do slider
document.addEventListener("DOMContentLoaded", function() {
    const rangeInput = document.getElementById("quantidadePalpites");
    const valorSpan = document.getElementById("valorQuantidadePalpites");
    
    if (rangeInput && valorSpan) {
        rangeInput.addEventListener("input", function() {
            valorSpan.textContent = formatarNumeroParaBR(parseInt(this.value));
        });
    }
});

// Fun√ß√µes para o modal da tabela completa
function formatarNumero(numero) {
  return numero.toLocaleString('pt-BR');
}

function abrirModal() {
  const modal = document.getElementById('modalTabelaCompleta');
  const tbody = document.getElementById('tabelaCompletaBody');
  
  // Limpar conte√∫do anterior
  tbody.innerHTML = '';
  
  // Preencher com dados de 2 a 60
  for (let digitos = 2; digitos <= 60; digitos++) {
    // Calcular agrupamentos de 2
    const agrupamentos = digitos * (digitos - 1);
    
    // Calcular palpites para Mega Sena
    let palpites;
    if (digitos < 6) {
      // Valores especiais para menos de 6 d√≠gitos
      palpites = digitos === 2 ? "-" : digitos === 3 ? "1" : digitos === 4 ? "2" : "3";
    } else {
      // Para 6 ou mais d√≠gitos, usamos C(n,6)
      const valor = calcularTotalCombinacoesPossiveis(digitos, 6);
      palpites = valor > 999 ? formatarNumero(valor) : valor;
    }
    
    // Criar a linha da tabela
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${digitos}</td>
      <td>${formatarNumero(agrupamentos)}</td>
      <td>${palpites}</td>
    `;
    
    tbody.appendChild(tr);
  }
  
  // Exibir o modal
  modal.style.display = 'block';
}

function fecharModal() {
  document.getElementById('modalTabelaCompleta').style.display = 'none';
}

// Fechar o modal quando o usu√°rio clicar fora dele
window.onclick = function(event) {
  const modal = document.getElementById('modalTabelaCompleta');
  if (event.target === modal) {
    modal.style.display = 'none';
  }
}

// Fechar o modal quando pressionar ESC
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    document.getElementById('modalTabelaCompleta').style.display = 'none';
  }
});

// Certifique-se de que esta vari√°vel global √© inicializada
window.combinacoesGeradas = [];



// Fun√ß√£o para validar entrada de d√≠gitos
function validarEntradaDigitos() {
    const inputDigitos = document.getElementById("numeros");
    const errorDiv = document.getElementById("numerosError");
    
    // Validar o padr√£o enquanto o usu√°rio digita
    inputDigitos.addEventListener("input", function(e) {
        const valor = e.target.value;
        
        // Remover espa√ßos em branco
        const valorSemEspacos = valor.replace(/\s/g, "");
        
        // Verificar se cont√©m apenas d√≠gitos (0-9) e v√≠rgulas
        const regex = /^[0-9,]*$/;
        if (!regex.test(valorSemEspacos)) {
            errorDiv.textContent = "Por favor, insira apenas d√≠gitos (0-9) separados por v√≠rgulas.";
            errorDiv.style.display = "block";
            return;
        }
        
        // Verificar se tem n√∫meros de dois d√≠gitos (sem v√≠rgula entre eles)
        const digitos = valorSemEspacos.split(",");
        for (const digito of digitos) {
            if (digito.length > 1) {
                errorDiv.textContent = "Cada d√≠gito deve ser separado por v√≠rgula. Insira apenas um d√≠gito por vez (0-9).";
                errorDiv.style.display = "block";
                return;
            }
        }
        
        // Verificar d√≠gitos duplicados e se est√£o no intervalo 0-9
        const digitosNumericos = digitos.filter(d => d !== "").map(d => parseInt(d, 10));
        const digitosUnicos = new Set(digitosNumericos);
        
        if (digitosNumericos.length > digitosUnicos.size) {
            errorDiv.textContent = "N√£o √© permitido repetir d√≠gitos. Use cada d√≠gito apenas uma vez.";
            errorDiv.style.display = "block";
            return;
        }
        
        // Verificar se todos os d√≠gitos est√£o no intervalo 0-9
        for (const digito of digitosNumericos) {
            if (digito < 0 || digito > 9) {
                errorDiv.textContent = "Apenas d√≠gitos entre 0 e 9 s√£o permitidos.";
                errorDiv.style.display = "block";
                return;
            }
        }
        
        // Se passou em todas as valida√ß√µes
        errorDiv.style.display = "none";
    });
    
    // Validar tamb√©m no evento de submiss√£o do formul√°rio
    document.getElementById("formCombinacoes").addEventListener("submit", function(e) {
        const valor = inputDigitos.value;
        const valorSemEspacos = valor.replace(/\s/g, "");
        
        // Verificar se cont√©m apenas d√≠gitos (0-9) e v√≠rgulas
        const regex = /^[0-9,]*$/;
        if (!regex.test(valorSemEspacos)) {
            e.preventDefault();
            errorDiv.textContent = "Por favor, insira apenas d√≠gitos (0-9) separados por v√≠rgulas.";
            errorDiv.style.display = "block";
            return false;
        }
        
        // Verificar se tem n√∫meros de dois d√≠gitos (sem v√≠rgula entre eles)
        const digitos = valorSemEspacos.split(",");
        for (const digito of digitos) {
            if (digito.length > 1) {
                e.preventDefault();
                errorDiv.textContent = "Cada d√≠gito deve ser separado por v√≠rgula. Insira apenas um d√≠gito por vez (0-9).";
                errorDiv.style.display = "block";
                return false;
            }
        }
        
        // Verificar d√≠gitos duplicados e se est√£o no intervalo 0-9
        const digitosNumericos = digitos.filter(d => d !== "").map(d => parseInt(d, 10));
        const digitosUnicos = new Set(digitosNumericos);
        
        if (digitosNumericos.length > digitosUnicos.size) {
            e.preventDefault();
            errorDiv.textContent = "N√£o √© permitido repetir d√≠gitos. Use cada d√≠gito apenas uma vez.";
            errorDiv.style.display = "block";
            return false;
        }
        
        // Verificar se todos os d√≠gitos est√£o no intervalo 0-9
        for (const digito of digitosNumericos) {
            if (digito < 0 || digito > 9) {
                e.preventDefault();
                errorDiv.textContent = "Apenas d√≠gitos entre 0 e 9 s√£o permitidos.";
                errorDiv.style.display = "block";
                return false;
            }
        }
        
        // Se passou em todas as valida√ß√µes
        return true;
    });
}

// Fun√ß√£o para criar tabela formatada para Excel
function criarTabelaCombinacoes(combinacoes) {
    // Filtrar para remover completamente n√∫meros acima de 60
    const combinacoesFiltradas = combinacoes.filter(comb => {
        const num = parseInt(comb);
        return num > 0 && num <= 60; // Garantir que esteja no intervalo 1-60
    });
    
    // Ordenar numericamente (n√£o alfabeticamente)
    combinacoesFiltradas.sort((a, b) => parseInt(a) - parseInt(b));
    
    // Configurar tabela com exatos 6 n√∫meros por linha (padr√£o Mega Sena)
    const numeroColunas = 6;
    const numeroLinhas = Math.ceil(combinacoesFiltradas.length / numeroColunas);
    
    const tabela = document.createElement('table');
    tabela.className = 'table table-bordered tabela-excel';
    
    const tbody = document.createElement('tbody');
    let index = 0;
    
    for (let i = 0; i < numeroLinhas; i++) {
        const row = document.createElement('tr');
        
        for (let j = 0; j < numeroColunas; j++) {
            const cell = document.createElement('td');
            
            if (index < combinacoesFiltradas.length) {
                const num = parseInt(combinacoesFiltradas[index]);
                
                // Formatar com zero √† esquerda para n√∫meros < 10
                cell.textContent = num < 10 ? `0${num}` : num;
                cell.className = 'celula-excel';
            } else {
                // C√©lula vazia para completar a linha
                cell.innerHTML = '&nbsp;';
            }
            
            row.appendChild(cell);
            index++;
        }
        
        tbody.appendChild(row);
    }
    
    tabela.appendChild(tbody);
    return tabela;
}

document.addEventListener("DOMContentLoaded", function() {
    // Garantir que o tamanho do agrupamento seja fixo em 2
    const tamanhoInput = document.getElementById("tamanho");
    tamanhoInput.value = "2";
    tamanhoInput.setAttribute("readonly", "readonly");
    tamanhoInput.style.backgroundColor = "#f8f9fa"; // Fundo cinza para indicar que √© somente leitura
    
    // Inicializar outras fun√ß√µes
    validarEntradaDigitos();
    
    // Tamb√©m adicionar mensagem de instru√ß√£o inicial
    const inputDigitos = document.getElementById("numeros");
    inputDigitos.setAttribute("placeholder", "ex: 0,1,2,3,4,5");
});
// Fun√ß√£o para gerar palpites (modificada para suportar ass√≠ncrono)
async function gerarPalpitesMegaSena() {
    // Verificar se temos combina√ß√µes geradas
    if (!window.combinacoesGeradas || window.combinacoesGeradas.length === 0) {
        alert("Por favor, gere as combina√ß√µes primeiro.");
        return;
    }
    
    // Obter a quantidade desejada de palpites
    const quantidadePalpites = parseInt(document.getElementById("quantidadePalpites").value);
    
    try {
        // Mostrar indicador de carregamento para todos os casos
        document.getElementById("palpitesCard").style.display = "block";
        
        // Determinar se o processamento ser√° ass√≠ncrono ou s√≠ncrono
        const isProcessamentoAssincrono = quantidadePalpites > 50;
        
        if (isProcessamentoAssincrono) {
            // Exibir a interface de processamento ass√≠ncrono
            document.getElementById("processamentoAssincrono").style.display = "block";
            document.getElementById("progressoTarefa").style.width = "0%";
            document.getElementById("statusTarefa").textContent = "Iniciando processamento...";
            document.getElementById("mensagemTarefa").className = "alert alert-info";
            document.getElementById("btnNovoProcessamento").style.display = "none";
        } else {
            // Para processamento s√≠ncrono, mostrar mensagem de carregamento
            document.getElementById("palpites").innerHTML = 
                `<div class="alert alert-info">
                    <div class="spinner-border spinner-border-sm" role="status">
                        <span class="visually-hidden">Carregando...</span>
                    </div>
                    Gerando ${quantidadePalpites} palpites...
                </div>`;
        }
        
        const response = await fetch("/gerar_palpites", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ 
                combinacoes: window.combinacoesGeradas,
                quantidade: quantidadePalpites
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            if (data.processamento === "ass√≠ncrono") {
                // Processamento ass√≠ncrono - conectar ao WebSocket
                document.getElementById("statusTarefa").textContent = 
                    `Iniciado processamento em segundo plano. Aguarde atualiza√ß√µes...`;
                
                // Iniciar o Socket.IO e inscrever-se na tarefa
                if (typeof initSocketIO === 'function') {
                    const socketioUrl = document.getElementById("socketioUrl").value || "http://localhost:10001";
                    initSocketIO(socketioUrl);
                    subscribeToTask(data.task_id);
                } else {
                    // WebSocket n√£o dispon√≠vel, usar polling
                    iniciarPolling(data.task_id);
                }
            } else {
                // Processamento s√≠ncrono - exibir resultados imediatamente
                document.getElementById("totalPalpites").textContent = data.total;
                
                // Exibir os palpites
                exibirPalpites(data.palpites);
                
                // Esconder processamento ass√≠ncrono se estiver vis√≠vel
                document.getElementById("processamentoAssincrono").style.display = "none";
            }
        } else {
            // Erro na resposta
            const mensagem = data.erro || "Erro ao gerar palpites";
            alert(mensagem);
            
            // Atualizar interface de processamento se vis√≠vel
            if (isProcessamentoAssincrono) {
                document.getElementById("statusTarefa").textContent = `Erro: ${mensagem}`;
                document.getElementById("mensagemTarefa").className = "alert alert-danger";
                document.getElementById("btnNovoProcessamento").style.display = "inline-block";
            }
        }
    } catch (error) {
        // Erro de comunica√ß√£o
        alert("Erro ao comunicar com o servidor");
        console.error(error);
        
        // Atualizar interface se necess√°rio
        const statusElement = document.getElementById("statusTarefa");
        if (statusElement) {
            statusElement.textContent = "Erro de comunica√ß√£o com o servidor";
            document.getElementById("mensagemTarefa").className = "alert alert-danger";
            document.getElementById("btnNovoProcessamento").style.display = "inline-block";
        }
    }
}

// Fun√ß√£o para polling (backup caso WebSockets n√£o esteja dispon√≠vel)
function iniciarPolling(taskId) {
    const intervalId = setInterval(async () => {
        try {
            const response = await fetch(`/verificar_tarefa/${taskId}`);
            const data = await response.json();
            
            // Simular atualiza√ß√£o de WebSocket
            atualizarProgressoTarefa({
                status: data.status,
                progress: Math.floor((data.current / data.total) * 100),
                message: data.status,
                result: data.resultado
            });
            
            // Se conclu√≠do ou falhou, parar o polling
            if (data.status === 'conclu√≠do' || data.status === 'falha') {
                clearInterval(intervalId);
            }
        } catch (error) {
            console.error("Erro no polling:", error);
        }
    }, 2000); // Verificar a cada 2 segundos
}

// Fun√ß√£o para exibir os palpites
function exibirPalpites(palpites) {
    const palpitesDiv = document.getElementById("palpites");
    palpitesDiv.innerHTML = "";
    
    // Criando tabela de palpites
    const table = document.createElement("table");
    table.className = "table table-striped";
    
    const thead = document.createElement("thead");
    const headerRow = document.createElement("tr");
    
    // Cabe√ßalho numerado de 1 a 6
    for (let i = 1; i <= 6; i++) {
        const th = document.createElement("th");
        th.textContent = `N¬∫ ${i}`;
        headerRow.appendChild(th);
    }
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    const tbody = document.createElement("tbody");
    
    // Adicionar cada palpite como uma linha
    palpites.forEach((palpite) => {
        const row = document.createElement("tr");
        
        // Cada n√∫mero do palpite em uma c√©lula
        palpite.forEach(numero => {
            const cell = document.createElement("td");
            cell.textContent = numero;
            row.appendChild(cell);
        });
        
        tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    palpitesDiv.appendChild(table);
}

// Event handler para o bot√£o de novo processamento
document.addEventListener("DOMContentLoaded", function() {
    const btnNovo = document.getElementById("btnNovoProcessamento");
    if (btnNovo) {
        btnNovo.addEventListener("click", function() {
            // Esconder o card de processamento
            document.getElementById("processamentoAssincrono").style.display = "none";
            // Limpar o task ID atual
            if (typeof currentTaskId !== 'undefined') {
                currentTaskId = null;
            }
        });
    }
});

#supervisord.conf
#Se voc√™ estiver no Windows, certifique-se tamb√©m de que o arquivo de configura√ß√£o do Supervisor (supervisord.conf) est√° ajustado corretamente para o ambiente Windows. 
#Os caminhos no Windows usam barras invertidas (\) ou precisam ser escapados corretamente.



pidfile=C:\\tmp\\supervisord.pid
nodaemon=false
minfds=1024
minprocs=200

[supervisorctl]
serverurl=http://127.0.0.1:9001

[program:flask_app]
command=python app.py
directory=C:\\caminho\\para\\Combinacao-I
autostart=true
autorestart=true
stderr_logfile=C:\\caminho\\para\\Combinacao-I\\logs\\flask_err.log
stdout_logfile=C:\\caminho\\para\\Combinacao-I\\logs\\flask_out.log

[program:socketio_server]
command=python socketio_server.py
directory=C:\\caminho\\para\\Combinacao-I
autostart=true
autorestart=true
stderr_logfile=C:\\caminho\\para\\Combinacao-I\\logs\\socketio_err.log
stdout_logfile=C:\\caminho\\para\\Combinacao-I\\logs\\socketio_out.log

[program:celery_worker]
command=celery -A celery_config worker --loglevel=info
directory=C:\\caminho\\para\\Combinacao-I
autostart=true
autorestart=true
stderr_logfile=C:\\caminho\\para\\Combinacao-I\\logs\\celery_err.log
stdout_logfile=C:\\caminho\\para\\Combinacao-I\\logs\\celery_out.log


<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Combina√ß√µes</title>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">
	<script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
	<script src="{{ url_for('static', filename='js/websocket.js') }}"></script>
	<script src="{{ url_for('static', filename='js/websocket_connect.js') }}"></script>
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center mb-4">Calculadora de Combina√ß√µes (Digitos)</h1>
			<p>A tabela abaixo mostra quantas combina√ß√µes ser√° poss√≠vel formar, conforme o total de digitos informado. </p>
			<p>Acesso tamb√©m o modal, para as combina√ß√µes completas.</p>
		<table>
		  <thead>
			<tr>
			  <th>N¬∫ de D√≠gitos</th>
			  <th>Agrupamentos de 2 <small>(Concidere as dezenas g√™meas para o n¬∫ de d√≠gitos)*</small></th>
			  <th>Palpites (Mega Sena)</th>
			</tr>
		  </thead>
		  <tbody>
			<tr>
			  <td>2 *</td>
			  <td>2</td>
			  <td>-</td>
			</tr>
			<tr>
			  <td>3 *</td>
			  <td>6</td>
			  <td>1</td>
			</tr>
			<tr>
			  <td>4 *</td>
			  <td>12</td>
			  <td>2</td>
			</tr>
			<tr>
			  <td>5 *</td>
			  <td>20</td>
			  <td>3</td>
			</tr>
			<tr>
			  <td>6 *</td>
			  <td>30</td>
			  <td>5</td>
			</tr>
			<tr>
			  <td>7 *</td>
			  <td>42</td>
			  <td>7</td>
			</tr>
			<tr>
			  <td>8 *</td>
			  <td>56</td>
			  <td>28</td>
			</tr>
			<tr>
			  <td>9 *</td>
			  <td>72</td>
			  <td>84</td>
			</tr>
			<tr>
			  <td>10 *</td>
			  <td>90</td>
			  <td>210</td>
			</tr>
			<tr>
			  <td>11 *</td>
			  <td>110</td>
			  <td>462</td>
			</tr>
			<tr>
			  <td>12 *</td>
			  <td>132</td>
			  <td>924</td>
			</tr>
            <tr>
              <td>13 *</td>
              <td>156</td>
              <td>1.716</td>
            </tr>
            <tr>
              <td>14 *</td>
              <td>182</td>
              <td>3.003</td>
            </tr>
            <tr>
              <td>15 *</td>
              <td>210</td>
              <td>5.005</td>
            </tr>
            <tr>
              <td>16 *</td>
              <td>240</td>
              <td>8.008</td>
            </tr>
            <tr>
              <td>17 *</td>
              <td>272</td>
              <td>12.376</td>
            </tr>
            <tr>
              <td>18 *</td>
              <td>306</td>
              <td>18.564</td>
            </tr>
            <tr>
              <td>19 *</td>
              <td>342</td>
              <td>27.132</td>
            </tr>
            <tr>
              <td>20 *</td>
              <td>380</td>
              <td>38.760</td>
            </tr>
		  </tbody>
		</table>

        <!-- Bot√£o para abrir o modal com a tabela completa -->
        <div class="text-center mt-3 mb-3">
          <button class="btn btn-primary" onclick="abrirModal()">Ver Tabela Completa (at√© 60 d√≠gitos) *</button>
        </div>
        
			<hr /><hr />
<div class="card">
    <div class="card-body">
        <form id="formCombinacoes" onsubmit="calcularCombinacoes(event)">
            <div class="mb-3">
                <label for="numeros" class="form-label">Digite os n√∫meros (separados por v√≠rgula):</label>
                <input type="text" class="form-control" id="numeros" required placeholder="ex: 1,2,0">
                <div class="error-message" id="numerosError"></div>
            </div>
            
            <div class="mb-3">
                <label for="tamanho" class="form-label">Tamanho do agrupamento:</label>
                <!-- O tamanho do agrupamento √© fixo e n√£o pode ser alterado -->
                <input type="number" class="form-control" id="tamanho" value="2" readonly required>
                <div class="error-message" id="tamanhoError"></div>
            </div>
            
            <button type="submit" class="btn btn-primary">Calcular Combina√ß√µes</button>
        </form>
    </div>
</div>

<div class="mt-4">
		<div class="alert alert-info" id="totalCombinacoes" style="display: none;">
			Total de Combina√ß√µes: <span id="total" class="badge bg-primary fs-4">0</span>
		</div>
		
		<div class="card mt-3" id="resultadoCard" style="display: none;">
			<div class="card-header">
				Combina√ß√µes Encontradas
			</div>
			<div class="card-body resultado-box">
				<div id="combinacoes"></div>
			</div>
		</div>
		
		<hr /><hr />

		<div id="palpitesControle" class="card mt-3" style="display: none;">
		  <div class="card-header bg-success text-white">
			Gerar Palpites para Mega Sena
		  </div>
		  <div class="card-body">
			<div class="row mb-2">
			  <div class="col-12">
				<div class="alert alert-info p-2">
				  <small>Com estes n√∫meros √© poss√≠vel formar at√© <strong id="totalTeorico">0</strong> palpites diferentes para a Mega Sena.</small>
				</div>
			  </div>
			</div>
			<div class="row align-items-center">
			  <div class="col-md-7">
				<label for="quantidadePalpites" class="form-label">Quantidade de palpites a gerar:</label>
				<input type="range" class="form-range" id="quantidadePalpites" min="1" max="100" value="10">
				<div class="d-flex justify-content-between mt-1">
				  <span>1</span>
				  <span class="text-center"><span id="valorQuantidadePalpites">10</span> de <span id="valorMaximo">100</span></span>
				  <span id="maxValue">Max</span>
				</div>
			  </div>
			  <div class="col-md-5">
				<button type="button" class="btn btn-success w-100" onclick="gerarPalpitesMegaSena()">
				  Gerar Palpites
				</button>
			  </div>
			</div>
		  </div>
		</div>

    <!-- O card de palpites permanece o mesmo -->
    <div class="card mt-3" id="palpitesCard" style="display: none;">
        <div class="card-header bg-success text-white">
            Palpites para Mega Sena (Total: <span id="totalPalpites">0</span>)
        </div>
        <div class="card-body resultado-box">
            <div id="palpites"></div>
        </div>
    </div>
</div>
	
	<footer>Feito por: <i>M√°rcio Fernando Maia -  Todos os direitos reservado - 2025</footer>

    <!-- Modal da tabela completa -->
    <div id="modalTabelaCompleta" class="modal-tabela">
      <div class="modal-conteudo">
        <div class="modal-header">
          <h2>Tabela Completa - At√© 60 D√≠gitos</h2>
          <span class="fechar-modal" onclick="fecharModal()">&times;</span>
        </div>
        <div class="table-responsive">
          <table>
            <thead>
              <tr>
                <th>N¬∫ de D√≠gitos</th>
                <th>Agrupamentos de 2</th>
                <th>Palpites (Mega Sena)</th>
              </tr>
            </thead>
            <tbody id="tabelaCompletaBody">
              <!-- Ser√° preenchido via JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <input type="hidden" id="socketioUrl" value="{{ socketio_url }}">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>

    <!-- Card para processamento ass√≠ncrono -->
    <div class="card mt-3" id="processamentoAssincrono" style="display: none;">
        <div class="card-header bg-info text-white">
            Processamento em Segundo Plano
        </div>
        <div class="card-body">
            <div class="progress mb-3">
                <div id="progressoTarefa" class="progress-bar progress-bar-striped progress-bar-animated" 
                     role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
            </div>
            
            <div id="mensagemTarefa" class="alert alert-info">
                <div class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
                <span id="statusTarefa">Iniciando processamento...</span>
            </div>
            
            <div id="controlesTarefa">
                <button id="btnNovoProcessamento" class="btn btn-outline-primary" style="display: none;">
                    Iniciar Novo Processamento
                </button>
            </div>
        </div>
    </div>
	
	<script>
		// Configura√ß√£o do WebSocket
		const socketioUrl = "http://" + window.location.hostname + ":10001";
		const socket = connectWebSocket(socketioUrl);	
	</script>

    <script>
        // Inicializar o Socket.IO quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const socketioUrl = document.getElementById('socketioUrl').value || "http://" + window.location.hostname + ":10001";
                console.log("Configurando conex√£o Socket.IO para:", socketioUrl);
                window.socket = connectWebSocket(socketioUrl);
            } catch (e) {
                console.error("Erro ao configurar Socket.IO:", e);
            }
        });
    </script>

</body>
</html>




.resultado-box {
  max-height: 300px;
  overflow-y: auto;
  padding: 15px;
  word-spacing: 10px; /* Adiciona espa√ßo extra entre os n√∫meros */
  font-family: monospace; /* Usa fonte monoespa√ßada para melhor alinhamento */
  font-size: 16px; /* Tamanho de fonte adequado */
  line-height: 2; /* Espa√ßamento entre linhas */
}

/* Estilo para tabela Excel */
.resultado-box table {
  width: 100%;
  border-collapse: collapse;
}

.resultado-box table td {
  border: 1px solid #ddd;
  text-align: center;
  padding: 8px;
  width: 16.66%; /* Para 6 colunas */
}

.celula-excel {
  user-select: all; /* Facilita a sele√ß√£o do conte√∫do */
  cursor: pointer;
}

.celula-excel:hover {
  background-color: #e9ecef;
}

/* Estilo para mensagens de erro */
.error-message {
  color: #dc3545;
  margin-top: 5px;
  display: none;
}

.numero {
  display: inline-block;
  padding: 5px 10px;
  margin: 2px;
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
}

.error-message {
  color: #dc3545;
  margin-top: 5px;
  display: none;
}

.btn-primary {
  display: inline-block;
  text-align: center;
}

footer {
  color: #161515;
  text-align: center;
  padding: 5px;
  margin-bottom: auto;
  margin-top: 10px; /* Espa√ßo acima do rodap√© */
}


/* Estilos para o modal da tabela completa */
.modal-tabela {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

.modal-conteudo {
  background-color: #fefefe;
  margin: 2% auto;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 900px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
}

.fechar-modal {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.fechar-modal:hover,
.fechar-modal:focus {
  color: black;
  text-decoration: none;
}

.modal-header {
  position: sticky;
  top: 0;
  background-color: white;
  z-index: 10;
  padding-bottom: 10px;
  margin-bottom: 10px;
  border-bottom: 1px solid #ddd;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-family: Arial, sans-serif;
}

thead {
  background-color: #007acc;
  color: white;
}

th, td {
  border: 1px solid #005f99;
  padding: 10px;
  text-align: center;
}

tbody tr:nth-child(even) {
  background-color: #cce5ff;
}

tbody tr:nth-child(odd) {
  background-color: #e6f2ff;
}

tbody tr:hover {
  background-color: #99ccff;
}
/* Estilos para a tabela Excel */
.tabela-excel {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 20px;
  table-layout: fixed; /* Garante que todas as c√©lulas tenham a mesma largura */
}

.tabela-excel td {
  border: 1px solid #ddd;
  text-align: center;
  padding: 8px;
  width: 16.66%; /* Exatamente 6 colunas de tamanho igual */
  height: 40px;
  vertical-align: middle;
  font-weight: 500;
  font-family: 'Courier New', monospace; /* Para melhor alinhamento */
}

/* Estilo especial para facilitar a sele√ß√£o do conte√∫do */
.celula-excel {
  user-select: all; /* Facilita a sele√ß√£o do conte√∫do */
  cursor: pointer;
  position: relative;
}

/* Feedback visual ao passar o mouse */
.celula-excel:hover {
  background-color: #e9ecef;
}

/* Estilo para quando a c√©lula √© clicada (selecionada) */
.celula-excel:active {
  background-color: #c0d8e8;
}

/* Estilos para as mensagens de erro */
.error-message {
  color: #dc3545;
  margin-top: 5px;
  font-size: 0.9rem;
  display: none;
  padding: 5px;
  border-radius: 3px;
  background-color: rgba(220, 53, 69, 0.1);
}
#tamanho {
    background-color: #f8f9fa;
    cursor: not-allowed;
}


@media only screen and (max-width: 600px) {
  .card-body {
    text-align: center;
  }

  button {
    display: inline-block;
  }

  footer {
    color: #f00303;
    font-style: italic;
  }
}

#.env
FLASK_APP=app.py
FLASK_ENV=development
FLASK_DEBUG=1



#REDIS_HOST=redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com
#REDIS_PORT=13833
#REDIS_PASSWORD=B058xThhTvAbptQa0s25EAGk7A5u473O
#REDIS_DB=0
#FLASK_ENV=development
#REDIS_URL=redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833
API_BASE_URL=https://loteriascaixa-api.herokuapp.com/api


REDIS_URL=redis://default:B058xThhTvAbptQa0s25EAGk7A5u473O@redis-13833.c336.samerica-east1-1.gce.redns.redis-cloud.com:13833

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*.class

# Environment
.env
venv/
env/
ENV/

# Flask
instance/
.webassets-cache

# Redis
dump.rdb

# Logs
*.log

# Outros
.DS_Store


flask==2.0.1
python-dotenv==0.19.0
Werkzeug==2.0.1
numpy==1.24.3
redis==4.5.5
eventlet==0.39.3 
celery==5.4.0
Flask-SocketIO==5.5.1
supervisor


# instalando os 3 junstos nesta configura√ß√£o deu erro..
# celery==5.2.7 (Sugerido pelo sistema)
# eventlet==0.33.3 (Sugerido pelo sistema)
# flask-socketio==5.3.2 (Sugerido pelo sistema)






#	amqp             5.3.1	
#	bidict           0.23.1	
#	billiard         4.2.1	
#	celery           5.4.0	
#	click            8.1.8	
#	click-didyoumean 0.3.1	
#	click-plugins    1.1.1	
#	click-repl       0.3.0	
#	colorama         0.4.6	
#	dnspython        2.7.0	
#	dotenv           0.9.9	
#	eventlet         0.39.0	
#	Flask            2.0.1	
#	Flask-SocketIO   5.5.1	
#	greenlet         3.1.1	
#	h11              0.14.0	
#	itsdangerous     2.2.0	
#	Jinja2           3.1.5	
#	kombu            5.4.2	
#	MarkupSafe       3.0.2	
#	numpy            2.2.3	
#	pip              25.0.1	
#	prompt_toolkit   3.0.50	
#	python-dateutil  2.9.0.post0	
#	python-dotenv    0.19.0	
#	python-engineio  4.11.2	
#	python-socketio  5.12.1	
#	redis            5.2.1	
#	setuptools       75.8.2	
#	simple-websocket 1.1.0	
#	six              1.17.0	
#	supervisor       4.2.5	
#	tzdata           2025.1	
#	vine             5.1.0	
#	wcwidth          0.2.13	
#	Werkzeug         2.0.1	
#	wsproto          1.2.0	









































































































































































































































































































































