1. Redis para cache e armazenamento - ok e funcional 

Armazenamento de resultados: Use o Redis para armazenar combinações geradas e palpites, evitando recalcular para inputs repetidos.
Implementação de filas: Use Redis List para criar um sistema de filas que permita processamento assíncrono de grandes volumes de combinações.

2. Otimizações de algoritmo

Algoritmos de geração incremental: Implemente algoritmos como Gosper's Hack ou algoritmo revolving-door que são mais eficientes para geração de combinações.
Paralelização: Divida o trabalho de geração de combinações em chunks que podem ser processados simultaneamente.

3. Processamento assíncrono e em segundo plano

Celery: Integre com Celery para processamento de tarefas em segundo plano.
WebSockets: Use WebSockets para atualizar o cliente sobre o progresso da geração sem bloquear a interface.

4. Otimizações na camada de banco de dados

Índices otimizados: Garanta que seus índices estejam otimizados para consultas frequentes.
Armazenamento eficiente: Considere armazenar combinações em formato binário para economizar espaço.

5. Paginação e carregamento sob demanda

API paginada: Retorne resultados em páginas pequenas em vez de todos de uma vez.
Carregamento infinito: Implemente scroll infinito no frontend para carregar mais resultados conforme o usuário rola a página.

6. Otimizações no Python

Numba/Cython: Use Numba ou Cython para compilar funções críticas de desempenho.
NumPy: Para operações matemáticas e de array, utilize NumPy que é mais eficiente.
PyPy: Considere usar o interpretador PyPy que oferece melhor desempenho para código Python puro.

7. Arquitetura distribuída

Microserviços: Divida sua aplicação em microserviços que podem escalar independentemente.
Clustering: Distribua o processamento em vários nós usando ferramentas como Kubernetes.

8. Compressão e otimização de transferência

gzip/Brotli: Comprima respostas HTTP.
Formatos binários: Use MessagePack ou Protocol Buffers em vez de JSON para transferências de dados.

9. Monitoramento e análise de desempenho

Profiling: Use ferramentas como cProfile, line_profiler ou py-spy para identificar gargalos.
APM: Implemente ferramentas de Application Performance Monitoring como New Relic ou Datadog.

10. Estratégias específicas para combinatória

Representação bit-a-bit: Use representações bit-a-bit para conjuntos e operações de conjunto.
Pré-computação: Pré-compute resultados comuns e armazene-os.
 
 
 Diretório: J:\Meu Drive\ProjetosPython\Loterias\Combinacoes\Combinacao-I


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        27/02/2025     03:59                .git
d-----        26/02/2025     10:34                Requisitos
d-----        23/02/2025     05:58                venv
d-----        26/02/2025     18:15                logs
d-----        26/02/2025     18:56                templates
d-----        23/02/2025     05:58                static
------        23/02/2025     06:52              0 README.md
------        23/02/2025     05:15           1096 LICENSE
------        23/02/2025     06:41          10138 combinacaoI.ps1
------        27/02/2025     11:59          10332 app.py
------        23/02/2025     05:58             57 requirements.txt
------        23/02/2025     05:58             59 .env
------        27/02/2025     11:59          10764 app.py.bak

from flask import Flask, render_template, request, jsonify
import itertools
from typing import List, Set
import logging
from logging.handlers import RotatingFileHandler
import os
import random
import time  # Para o caso de uso de sleep no código

app = Flask(__name__)

# Configuração de logs
if not os.path.exists('logs'):
    os.mkdir('logs')
file_handler = RotatingFileHandler('logs/combinacoes.log', maxBytes=10240, backupCount=10)
file_handler.setFormatter(logging.Formatter(
    '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
))
file_handler.setLevel(logging.INFO)
app.logger.addHandler(file_handler)
app.logger.setLevel(logging.INFO)
app.logger.info('Iniciando aplicação de combinações')

def gerar_combinacoes(numeros: List[int], tamanho: int) -> Set[tuple]:
    """
    Gera combinações normais e adiciona combinações gêmeas.
    """
    # Gerar combinações normais usando permutações dos números originais
    combinacoes = set(itertools.permutations(numeros, tamanho))
    
    # Adicionar combinações gêmeas (onde os dois dígitos são iguais)
    for num in numeros:
        if 1 <= num <= 9:
            gemeo = (num, num)  # Por exemplo, (1,1) para formar "11"
            combinacoes.add(gemeo)
    
    return combinacoes

def formatar_numero(combinacao: tuple) -> str:
    """Formata uma combinação como uma string de dígitos concatenados."""
    return "".join(map(str, combinacao))

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/calcular", methods=["POST"])
def calcular():
    try:
        dados = request.get_json()
        numeros_str = dados.get("numeros", "")
        tamanho = int(dados.get("tamanho", 0))
        
        app.logger.info(f'Calculando combinações para números: {numeros_str}, tamanho: {tamanho}')
        
        # Validação dos dados
        if not numeros_str or tamanho < 1:
            app.logger.warning('Dados inválidos recebidos')
            return jsonify({"erro": "Dados inválidos"}), 400
        
        # Processamento dos números - CORRIGIDO: removida a adição de gêmeos aqui
        numeros = [int(n.strip()) for n in numeros_str.split(",")]
        
        # Cálculo das combinações
        combinacoes = gerar_combinacoes(numeros, tamanho)
        combinacoes_formatadas = [formatar_numero(c) for c in combinacoes]
        combinacoes_formatadas.sort()
        
        app.logger.info(f'Geradas {len(combinacoes)} combinações')
        
        return jsonify({
            "total": len(combinacoes),
            "combinacoes": combinacoes_formatadas
        })
        
    except ValueError as e:
        app.logger.error(f'Erro nos dados de entrada: {str(e)}')
        return jsonify({"erro": f"Erro nos dados de entrada: {str(e)}"}), 400
    except Exception as e:
        app.logger.error(f'Erro inesperado: {str(e)}')
        return jsonify({"erro": f"Erro inesperado: {str(e)}"}), 500

# Função otimizada de gerar palpites para a Mega Sena
def gerar_palpites_mega_sena(combinacoes_formatadas, total_palpites=10):
    """
    Gera palpites para a Mega Sena a partir das combinações de dois dígitos.
    Cada palpite contém 6 números únicos entre 1 e 60.
    
    Args:
        combinacoes_formatadas: Lista de combinações de dois dígitos já formatadas
        total_palpites: Número de palpites a serem gerados
        
    Returns:
        Uma lista de palpites, onde cada palpite é uma lista de 6 números únicos
    """
    numeros_unicos = set()
    
    # Extrair números das combinações de dois dígitos
    for combinacao in combinacoes_formatadas:
        i = 0
        while i < len(combinacao):
            # Tentar extrair um número de 2 dígitos
            if i + 1 < len(combinacao):
                try:
                    num_str = combinacao[i:i+2]
                    numero = int(num_str)
                    if 1 <= numero <= 60:  # Garantir que está no intervalo da Mega Sena
                        numeros_unicos.add(numero)
                except ValueError:
                    pass
            i += 2  # Avançar para o próximo par de dígitos
    
    # Converter o conjunto para lista para facilitar a manipulação
    numeros_disponiveis = list(numeros_unicos)
    
    # Se não houver números suficientes, complementar com números aleatórios
    if len(numeros_disponiveis) < 6:
        numeros_faltantes = set(range(1, 61)) - set(numeros_disponiveis)
        numeros_complementares = random.sample(list(numeros_faltantes), 6 - len(numeros_disponiveis))
        numeros_disponiveis.extend(numeros_complementares)
    
    # Garantir que temos pelo menos 6 números
    if len(numeros_disponiveis) < 6:
        raise ValueError("Não foi possível extrair números suficientes das combinações")
    
    # Para geração de grandes quantidades, usamos uma abordagem mais eficiente
    if total_palpites > 100:
        return gerar_palpites_grande_quantidade(numeros_disponiveis, total_palpites)
    
    # Para quantidades menores, usamos a abordagem normal
    palpites = []
    tentativas_maximas = total_palpites * 3  # Tentativas extras caso gere duplicatas
    tentativas = 0
    
    while len(palpites) < total_palpites and tentativas < tentativas_maximas:
        tentativas += 1
        
        # Se tivermos muitos números disponíveis, podemos gerar mais variações
        if len(numeros_disponiveis) > 15:
            # Escolher 6 números aleatórios do conjunto disponível
            palpite = sorted(random.sample(numeros_disponiveis, 6))
        else:
            # Para conjuntos menores, podemos precisar de uma abordagem mais criativa
            # Garantir que pelo menos 3 números sejam dos disponíveis
            n_fixos = min(3, len(numeros_disponiveis))
            numeros_fixos = random.sample(numeros_disponiveis, n_fixos)
            
            # Complementar com números aleatórios entre 1-60 que não estejam nos fixos
            numeros_adicionais = []
            while len(numeros_fixos) + len(numeros_adicionais) < 6:
                novo_num = random.randint(1, 60)
                if novo_num not in numeros_fixos and novo_num not in numeros_adicionais:
                    numeros_adicionais.append(novo_num)
            
            # Juntar e ordenar
            palpite = sorted(numeros_fixos + numeros_adicionais)
        
        # Verificar se esse palpite já existe
        palpite_str = ",".join(map(str, palpite))
        palpites_existentes = [",".join(map(str, p)) for p in palpites]
        
        if palpite_str not in palpites_existentes:
            palpites.append(palpite)
    
    # Se não conseguimos gerar palpites suficientes, retornar o que temos
    return palpites

def gerar_palpites_grande_quantidade(numeros_disponiveis, total_palpites):
    """
    Método otimizado para gerar grandes quantidades de palpites.
    Usa um conjunto para verificação rápida de duplicatas.
    """
    palpites_set = set()
    palpites = []
    
    alta_variabilidade = len(numeros_disponiveis) >= 15
    
    max_tentativas = total_palpites * 5
    tentativas = 0
    
    while len(palpites) < total_palpites and tentativas < max_tentativas:
        tentativas += 1
        
        if alta_variabilidade:
            if len(numeros_disponiveis) >= 6:
                palpite = tuple(sorted(random.sample(numeros_disponiveis, 6)))
            else:
                numeros_base = list(numeros_disponiveis)
                complementos_necessarios = 6 - len(numeros_base)
                complementos = []
                
                while len(complementos) < complementos_necessarios:
                    num = random.randint(1, 60)
                    if num not in numeros_base and num not in complementos:
                        complementos.append(num)
                
                palpite = tuple(sorted(numeros_base + complementos))
        else:
            n_disponiveis = min(4, len(numeros_disponiveis))
            
            if n_disponiveis > 0:
                numeros_base = random.sample(numeros_disponiveis, n_disponiveis)
            else:
                numeros_base = []
                
            complementos = []
            while len(numeros_base) + len(complementos) < 6:
                num = random.randint(1, 60)
                if num not in numeros_base and num not in complementos:
                    complementos.append(num)
            
            palpite = tuple(sorted(numeros_base + complementos))
        
        if palpite not in palpites_set:
            palpites_set.add(palpite)
            palpites.append(list(palpite))
            
            # A cada 100 palpites, fazer uma pausa para diminuir a carga na CPU
            if len(palpites) % 100 == 0 and len(palpites) < total_palpites:
                time.sleep(0.01)
    
    return palpites

@app.route("/gerar_palpites", methods=["POST"])
def gerar_palpites():
    try:
        dados = request.get_json()
        combinacoes_formatadas = dados.get("combinacoes", [])
        total_palpites = int(dados.get("quantidade", 10)) # Mudou "total_palpites" para "quantidade"
        
        app.logger.info(f'Gerando {total_palpites} palpites para a Mega Sena.')
        
        # Validação
        if not combinacoes_formatadas or total_palpites <= 0:
            app.logger.warning('Dados de entrada para geração de palpites inválidos')
            return jsonify({"erro": "Dados inválidos"}), 400
        
        palpites = gerar_palpites_mega_sena(combinacoes_formatadas, total_palpites)
        
        app.logger.info(f'Gerados {len(palpites)} palpites')
        
        return jsonify({"total": len(palpites), "palpites": palpites})# Mudou "total_palpites" para "total"
    
    except Exception as e:
        app.logger.error(f'Erro inesperado ao gerar palpites: {str(e)}')
        return jsonify({"erro": f"Erro inesperado: {str(e)}"}), 500

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 10000))
    app.run(host="0.0.0.0", port=port)
	
	
	// Função para calcular o número total de combinações possíveis
function calcularTotalCombinacoesPossiveis(n, r) {
  // Função para calcular fatorial (limita a números menores para evitar overflow)
  function fatorial(num) {
    if (num <= 1) return 1;
    let resultado = 1;
    for (let i = 2; i <= num; i++) {
      resultado *= i;
    }
    return resultado;
  }
  
  // Para números grandes, usamos uma abordagem mais eficiente
  function calcularCombinacaoGrande(n, r) {
    let resultado = 1;
    // Calcular n! / (n-r)! diretamente
    for (let i = n - r + 1; i <= n; i++) {
      resultado *= i;
    }
    // Dividir por r!
    resultado /= fatorial(r);
    return Math.floor(resultado);
  }
  
  if (n < r) return 0;
  
  // Usar método apropriado baseado no tamanho dos números
  if (n > 20) {
    return calcularCombinacaoGrande(n, r);
  } else {
    return Math.floor(fatorial(n) / (fatorial(r) * fatorial(n - r)));
  }
}

// Função auxiliar para extrair números da lista de combinações formatadas
function extrairNumerosUnicos(combinacoes) {
  const numerosUnicos = new Set();
  
  for (const combinacao of combinacoes) {
    // Tentar extrair números de 2 dígitos da combinação
    let i = 0;
    while (i < combinacao.length) {
      if (i + 1 < combinacao.length) {
        try {
          const numStr = combinacao.substring(i, i+2);
          const numero = parseInt(numStr);
          if (numero >= 1 && numero <= 60) {
            numerosUnicos.add(numero);
          }
        } catch (e) {}
      }
      i += 2;
    }
  }
  
  return [...numerosUnicos];
}

// Função para calcular combinações
async function calcularCombinacoes(event) {
    event.preventDefault();
    
    const numeros = document.getElementById("numeros").value;
    const tamanho = document.getElementById("tamanho").value;
    
    try {
        const response = await fetch("/calcular", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ numeros, tamanho })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // Exibe o total
            document.getElementById("totalCombinacoes").style.display = "block";
            document.getElementById("total").textContent = data.total;
            
            // Exibe as combinações
            const combinacoesDiv = document.getElementById("combinacoes");
            combinacoesDiv.innerHTML = data.combinacoes.join(" ");
            document.getElementById("resultadoCard").style.display = "block";
            
            // Armazenar as combinações para uso posterior
            window.combinacoesGeradas = data.combinacoes;
            
            // Verificar se deve mostrar os controles de palpites
            const digitosInput = document.getElementById("numeros").value;
            const digitos = digitosInput.split(",").map(d => d.trim()).filter(d => d);
            const quantidadeDigitos = digitos.length;
            
            // Mostrar controles apenas se tivermos 4 ou mais dígitos
            const palpitesControle = document.getElementById("palpitesControle");
            if (quantidadeDigitos >= 4 && data.total >= 12) {
                palpitesControle.style.display = "block";
                
                // Calcular o total teórico de palpites possíveis
                // Primeiro extrair os números únicos das combinações geradas
                const numerosUnicosArray = extrairNumerosUnicos(data.combinacoes);
                console.log("Números únicos extraídos:", numerosUnicosArray);
                
                const totalTeorico = calcularTotalCombinacoesPossiveis(numerosUnicosArray.length, 6);
                console.log("Total teórico calculado:", totalTeorico);
                
                // Mostrar o total teórico na interface
                document.getElementById("totalTeorico").textContent = totalTeorico;
                
                // Ajustar o range para o total teórico (com limite prático de 1000 para não travar a interface)
                const limiteMaximo = Math.min(1000, Math.max(1, totalTeorico));
                const rangeInput = document.getElementById("quantidadePalpites");
                rangeInput.max = limiteMaximo;
                rangeInput.value = Math.min(10, limiteMaximo);
                document.getElementById("valorQuantidadePalpites").textContent = rangeInput.value;
                
                // Atualizar o texto do máximo
                document.getElementById("valorMaximo").textContent = limiteMaximo;
            } else {
                palpitesControle.style.display = "none";
                // Esconder o container de palpites caso esteja visível
                document.getElementById("palpitesCard").style.display = "none";
            }
        } else {
            alert(data.erro || "Erro ao calcular combinações");
        }
    } catch (error) {
        alert("Erro ao comunicar com o servidor");
        console.error(error);
    }
}

async function gerarPalpitesMegaSena() {
    // Verificar se temos combinações geradas
    if (!window.combinacoesGeradas || window.combinacoesGeradas.length === 0) {
        alert("Por favor, gere as combinações primeiro.");
        return;
    }
    
    // Obter a quantidade desejada de palpites
    const quantidadePalpites = parseInt(document.getElementById("quantidadePalpites").value);
    
    // Mostrar um indicador de carregamento para grandes quantidades
    if (quantidadePalpites > 50) {
        document.getElementById("palpitesCard").style.display = "block";
        document.getElementById("palpites").innerHTML = 
            `<div class="alert alert-info">
                <div class="spinner-border spinner-border-sm" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
                Gerando ${quantidadePalpites} palpites. Isso pode levar alguns segundos...
            </div>`;
    }
    
    try {
        const response = await fetch("/gerar_palpites", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ 
                combinacoes: window.combinacoesGeradas,
                quantidade: quantidadePalpites
            })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            // Exibe o total de palpites
            document.getElementById("totalPalpites").textContent = data.total;
            
            // Exibe os palpites
            const palpitesDiv = document.getElementById("palpites");
            palpitesDiv.innerHTML = "";
            
            // Criando tabela de palpites
            const table = document.createElement("table");
            table.className = "table table-striped";
            
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");
            
            // Cabeçalho numerado de 1 a 6
            for (let i = 1; i <= 6; i++) {
                const th = document.createElement("th");
                th.textContent = `Nº ${i}`;
                headerRow.appendChild(th);
            }
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            const tbody = document.createElement("tbody");
            
            // Adicionar cada palpite como uma linha
            data.palpites.forEach((palpite, index) => {
                const row = document.createElement("tr");
                
                // Cada número do palpite em uma célula
                palpite.forEach(numero => {
                    const cell = document.createElement("td");
                    cell.textContent = numero;
                    row.appendChild(cell);
                });
                
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            palpitesDiv.appendChild(table);
            
            // Exibe o card de palpites
            document.getElementById("palpitesCard").style.display = "block";
        } else {
            alert(data.erro || "Erro ao gerar palpites");
        }
    } catch (error) {
        alert("Erro ao comunicar com o servidor");
        console.error(error);
    }
}

// Adicione este event listener para atualizar o valor exibido do slider
document.addEventListener("DOMContentLoaded", function() {
    const rangeInput = document.getElementById("quantidadePalpites");
    const valorSpan = document.getElementById("valorQuantidadePalpites");
    
    if (rangeInput && valorSpan) {
        rangeInput.addEventListener("input", function() {
            valorSpan.textContent = this.value;
        });
    }
});

// Funções para o modal da tabela completa
function formatarNumero(numero) {
  return numero.toLocaleString('pt-BR');
}

function abrirModal() {
  const modal = document.getElementById('modalTabelaCompleta');
  const tbody = document.getElementById('tabelaCompletaBody');
  
  // Limpar conteúdo anterior
  tbody.innerHTML = '';
  
  // Preencher com dados de 2 a 60
  for (let digitos = 2; digitos <= 60; digitos++) {
    // Calcular agrupamentos de 2
    const agrupamentos = digitos * (digitos - 1);
    
    // Calcular palpites para Mega Sena
    let palpites;
    if (digitos < 6) {
      // Valores especiais para menos de 6 dígitos
      palpites = digitos === 2 ? "-" : digitos === 3 ? "1" : digitos === 4 ? "2" : "3";
    } else {
      // Para 6 ou mais dígitos, usamos C(n,6)
      const valor = calcularTotalCombinacoesPossiveis(digitos, 6);
      palpites = valor > 999 ? formatarNumero(valor) : valor;
    }
    
    // Criar a linha da tabela
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${digitos}</td>
      <td>${formatarNumero(agrupamentos)}</td>
      <td>${palpites}</td>
    `;
    
    tbody.appendChild(tr);
  }
  
  // Exibir o modal
  modal.style.display = 'block';
}

function fecharModal() {
  document.getElementById('modalTabelaCompleta').style.display = 'none';
}

// Fechar o modal quando o usuário clicar fora dele
window.onclick = function(event) {
  const modal = document.getElementById('modalTabelaCompleta');
  if (event.target === modal) {
    modal.style.display = 'none';
  }
}

// Fechar o modal quando pressionar ESC
document.addEventListener('keydown', function(event) {
  if (event.key === 'Escape') {
    document.getElementById('modalTabelaCompleta').style.display = 'none';
  }
});

// Certifique-se de que esta variável global é inicializada
window.combinacoesGeradas = [];

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Combinações</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">
</head>
<body>
    <div class="container mt-5">
        <h1 class="text-center mb-4">Calculadora de Combinações (Digitos)</h1>
			<p>A tabela abaixo mostra quantas combinações será possivel formar, conforme o total de digitos informado. </p>
			<p>Acesso também o modal, para as combinações completa.</p>
		<table>
		  <thead>
			<tr>
			  <th>Nº de Dígitos</th>
			  <th>Agrupamentos de 2 <small>(Concidere as dezenas gêmeas para o nº de dígitos)*</small></th>
			  <th>Palpites (Mega Sena)</th>
			</tr>
		  </thead>
		  <tbody>
			<tr>
			  <td>2 *</td>
			  <td>2</td>
			  <td>-</td>
			</tr>
			<tr>
			  <td>3 *</td>
			  <td>6</td>
			  <td>1</td>
			</tr>
			<tr>
			  <td>4 *</td>
			  <td>12</td>
			  <td>2</td>
			</tr>
			<tr>
			  <td>5 *</td>
			  <td>20</td>
			  <td>3</td>
			</tr>
			<tr>
			  <td>6 *</td>
			  <td>30</td>
			  <td>5</td>
			</tr>
			<tr>
			  <td>7 *</td>
			  <td>42</td>
			  <td>7</td>
			</tr>
			<tr>
			  <td>8 *</td>
			  <td>56</td>
			  <td>28</td>
			</tr>
			<tr>
			  <td>9 *</td>
			  <td>72</td>
			  <td>84</td>
			</tr>
			<tr>
			  <td>10 *</td>
			  <td>90</td>
			  <td>210</td>
			</tr>
			<tr>
			  <td>11 *</td>
			  <td>110</td>
			  <td>462</td>
			</tr>
			<tr>
			  <td>12 *</td>
			  <td>132</td>
			  <td>924</td>
			</tr>
            <tr>
              <td>13 *</td>
              <td>156</td>
              <td>1.716</td>
            </tr>
            <tr>
              <td>14 *</td>
              <td>182</td>
              <td>3.003</td>
            </tr>
            <tr>
              <td>15 *</td>
              <td>210</td>
              <td>5.005</td>
            </tr>
            <tr>
              <td>16 *</td>
              <td>240</td>
              <td>8.008</td>
            </tr>
            <tr>
              <td>17 *</td>
              <td>272</td>
              <td>12.376</td>
            </tr>
            <tr>
              <td>18 *</td>
              <td>306</td>
              <td>18.564</td>
            </tr>
            <tr>
              <td>19 *</td>
              <td>342</td>
              <td>27.132</td>
            </tr>
            <tr>
              <td>20 *</td>
              <td>380</td>
              <td>38.760</td>
            </tr>
		  </tbody>
		</table>

        <!-- Botão para abrir o modal com a tabela completa -->
        <div class="text-center mt-3 mb-3">
          <button class="btn btn-primary" onclick="abrirModal()">Ver Tabela Completa (até 60 dígitos) *</button>
        </div>
        
			<hr /><hr />
<div class="card">
    <div class="card-body">
        <form id="formCombinacoes" onsubmit="calcularCombinacoes(event)">
            <div class="mb-3">
                <label for="numeros" class="form-label">Digite os números (separados por vírgula):</label>
                <input type="text" class="form-control" id="numeros" required placeholder="ex: 1,2,0">
                <div class="error-message" id="numerosError"></div>
            </div>
            
            <div class="mb-3">
                <label for="tamanho" class="form-label">Tamanho do agrupamento:</label>
                <!-- O tamanho do agrupamento é fixo e não pode ser alterado -->
                <input type="number" class="form-control" id="tamanho" value="2" readonly required>
                <div class="error-message" id="tamanhoError"></div>
            </div>
            
            <button type="submit" class="btn btn-primary">Calcular Combinações</button>
        </form>
    </div>
</div>

<div class="mt-4">
		<div class="alert alert-info" id="totalCombinacoes" style="display: none;">
			Total de Combinações: <span id="total" class="badge bg-primary fs-4">0</span>
		</div>
		
		<div class="card mt-3" id="resultadoCard" style="display: none;">
			<div class="card-header">
				Combinações Encontradas
			</div>
			<div class="card-body resultado-box">
				<div id="combinacoes"></div>
			</div>
		</div>
		
		<hr /><hr />

		<div id="palpitesControle" class="card mt-3" style="display: none;">
		  <div class="card-header bg-success text-white">
			Gerar Palpites para Mega Sena
		  </div>
		  <div class="card-body">
			<div class="row mb-2">
			  <div class="col-12">
				<div class="alert alert-info p-2">
				  <small>Com estes números é possível formar até <strong id="totalTeorico">0</strong> palpites diferentes para a Mega Sena.</small>
				</div>
			  </div>
			</div>
			<div class="row align-items-center">
			  <div class="col-md-7">
				<label for="quantidadePalpites" class="form-label">Quantidade de palpites a gerar:</label>
				<input type="range" class="form-range" id="quantidadePalpites" min="1" max="100" value="10">
				<div class="d-flex justify-content-between mt-1">
				  <span>1</span>
				  <span class="text-center"><span id="valorQuantidadePalpites">10</span> de <span id="valorMaximo">100</span></span>
				  <span id="maxValue">Max</span>
				</div>
			  </div>
			  <div class="col-md-5">
				<button type="button" class="btn btn-success w-100" onclick="gerarPalpitesMegaSena()">
				  Gerar Palpites
				</button>
			  </div>
			</div>
		  </div>
		</div>

    <!-- O card de palpites permanece o mesmo -->
    <div class="card mt-3" id="palpitesCard" style="display: none;">
        <div class="card-header bg-success text-white">
            Palpites para Mega Sena (Total: <span id="totalPalpites">0</span>)
        </div>
        <div class="card-body resultado-box">
            <div id="palpites"></div>
        </div>
    </div>
</div>
	
	<footer>Feito por: <i>Márcio Fernando Maia -  Todos os direitos reservado - 2025</footer>

    <!-- Modal da tabela completa -->
    <div id="modalTabelaCompleta" class="modal-tabela">
      <div class="modal-conteudo">
        <div class="modal-header">
          <h2>Tabela Completa - Até 60 Dígitos</h2>
          <span class="fechar-modal" onclick="fecharModal()">&times;</span>
        </div>
        <div class="table-responsive">
          <table>
            <thead>
              <tr>
                <th>Nº de Dígitos</th>
                <th>Agrupamentos de 2</th>
                <th>Palpites (Mega Sena)</th>
              </tr>
            </thead>
            <tbody id="tabelaCompletaBody">
              <!-- Será preenchido via JavaScript -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>

.resultado-box {
  max-height: 300px;
  overflow-y: auto;
  padding: 15px;
  word-spacing: 10px; /* Adiciona espaço extra entre os números */
  font-family: monospace; /* Usa fonte monoespaçada para melhor alinhamento */
  font-size: 16px; /* Tamanho de fonte adequado */
  line-height: 2; /* Espaçamento entre linhas */
}

.numero {
  display: inline-block;
  padding: 5px 10px;
  margin: 2px;
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
}

.error-message {
  color: #dc3545;
  margin-top: 5px;
  display: none;
}

.btn-primary {
  display: inline-block;
  text-align: center;
}

footer {
  color: #161515;
  text-align: center;
  padding: 5px;
  margin-bottom: auto;
  margin-top: 10px; /* Espaço acima do rodapé */
}

@media only screen and (max-width: 600px) {
  .card-body {
    text-align: center;
  }

  button {
    display: inline-block;
  }

  footer {
    color: #f00303;
    font-style: italic;
  }
}

/* Estilos para o modal da tabela completa */
.modal-tabela {
  display: none;
  position: fixed;
  z-index: 9999;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
}

.modal-conteudo {
  background-color: #fefefe;
  margin: 2% auto;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 900px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
}

.fechar-modal {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.fechar-modal:hover,
.fechar-modal:focus {
  color: black;
  text-decoration: none;
}

.modal-header {
  position: sticky;
  top: 0;
  background-color: white;
  z-index: 10;
  padding-bottom: 10px;
  margin-bottom: 10px;
  border-bottom: 1px solid #ddd;
}

table {
  width: 100%;
  border-collapse: collapse;
  font-family: Arial, sans-serif;
}

thead {
  background-color: #007acc;
  color: white;
}

th, td {
  border: 1px solid #005f99;
  padding: 10px;
  text-align: center;
}

tbody tr:nth-child(even) {
  background-color: #cce5ff;
}

tbody tr:nth-child(odd) {
  background-color: #e6f2ff;
}

tbody tr:hover {
  background-color: #99ccff;
}

flask==2.0.1
python-dotenv==0.19.0
Werkzeug==2.0.1

FLASK_APP=app.py
FLASK_ENV=development
FLASK_DEBUG=1
